// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`containers/CommunityCreated/View should match the snapshot 1`] = `
<View__Container>
  <Head>
    <title>
      Community updated - Kauri
    </title>
  </Head>
  <Typography__styledComponent>
    Community
  </Typography__styledComponent>
  <Typography__component>
    Your community is now updated
  </Typography__component>
  <CommunityCard
    __typename="CommunityDTO"
    approved={
      Array [
        Object {
          "__typename": "ArticleDTO",
          "associatedNfts": null,
          "attributes": Object {
            "background": "https://api.kauri.io:443/ipfs/QmZjb5Kp3LFcXTVxneoJN3aco6NF91M7TbVfxUq4B4ySsX",
          },
          "author": Object {
            "__typename": "PublicUserDTO",
            "avatar": "https://api.dev.kauri.io:443/ipfs/QmXa9LzhDV4wiF9YLsv2Z9CBUaSU6ph8QLNRLTDAUBsrA8",
            "id": "f0f15cedc719b5a55470877b0710d5c7816916b1",
            "name": "Grégoire Jeanmart",
            "username": "gregjeanmart",
          },
          "authorId": "f0f15cedc719b5a55470877b0710d5c7816916b1",
          "checkpoint": null,
          "comments": Object {
            "__typename": "ResponsePage_CommentDTO",
            "content": Array [],
            "totalElements": 0,
            "totalPages": 0,
          },
          "content": "{\\"markdown\\":\\"\\\\n**Other articles in this series:**\\\\n- [Manage an Ethereum account with Java and Web3j](https://kauri.io/article/925d923e12c543da9a0a3e617be963b4)\\\\n- [Generate a Java Wrapper from your Smart Contract](https://kauri.io/article/84475132317d4d6a84a2c42eb9348e4b)\\\\n- [Interacting with an Ethereum Smart Contract in Java](https://kauri.io/article/14dc434d11ef4ee18bf7d57f079e246e)\\\\n- [Listening for Ethereum Smart Contract Events in Java](https://kauri.io/article/760f495423db42f988d17b8c145b0874)\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\\\n\\\\n---------------------------------------------------\\\\n\\\\n[**Ethereum**](https://www.ethereum.org/) is a Blockchain, which means it operates on a [peer-to-peer network](https://en.wikipedia.org/wiki/Peer-to-peer) composed of thousand of nodes where each node agrees on the next state.\\\\n\\\\nIn order to interact with the Ethereum global state (distributed database), a program needs to connect to a node that exposes the standard [JSON-RPC API](https://github.com/ethereum/wiki/wiki/JSON-RPC#json-rpc-api) which can be used to execute operations on the Ethereum blockchain.\\\\n\\\\nIn this article, we will learn how to start an Ethereum Java project and connect to a node using the Java library **[Web3j](https://web3j.io/)**, a lightweight and modular library implementing all the functionallities required to work with Ethereum (JSON-RPC API client, wallet account management, Java Smart Contract wrapper, support for ENS, ERC20 and ERC721 and much more).\\\\n\\\\n![](https://web3j.readthedocs.io/en/latest/_images/web3j_network.png)\\\\n\\\\n## Prerequisite\\\\n\\\\nTo run this tutorial, we must have the following installed:\\\\n\\\\n-   [Java programming language](https://java.com/en/download/) (> 8)\\\\n\\\\n\`\`\`shell\\\\n$ java -version\\\\njava version \\\\\\"1.8.0_201\\\\\\"\\\\n\`\`\`\\\\n\\\\n-   A package and dependancy manager, for example [Maven](https://maven.apache.org/) or [Gradle](https://gradle.org/install/)\\\\n-   An IDE (Integrated development environment), for this tutorial, we use [Eclipse](https://www.eclipse.org/downloads/)\\\\n\\\\n## Start a new project\\\\n\\\\nFirst create a new Maven project called \`java_ethereum\` in Eclipse.\\\\n\\\\n### 1. Create a new Maven project\\\\n\\\\nOnce Eclipse is launched, we need to create a new Maven project. Go to _File > New > Project > Maven > Maven Project_\\\\n\\\\nCheck the box _Create a simple project (skip archetype selection)_ and click on _Next >_.\\\\n\\\\nNext screen, enter the _Group ID_ and _Artifact ID_ of our project then click _Finish_.\\\\n\\\\nGroup Id: \`io.kauri.tutorials.java-ethereum\`\\\\n\\\\nArtifact Id: \`java-ethereum\`\\\\n\\\\n![](https://imgur.com/IpEZ6gX.png)\\\\n\\\\nIt should result of a new project in the _Project Explorer_\\\\n\\\\n![](https://imgur.com/7uiey3U.png)\\\\n\\\\n### 2. Configure our project to use Java 8\\\\n\\\\nFinally, we need to tell Eclipse and Maven to use Java version 8.\\\\n\\\\nEdit the file \`pom.xml\` and add the following lines before \`</project>\`\\\\n\\\\n\`\`\`xml\\\\n  <properties>\\\\n    <maven.compiler.target>1.8</maven.compiler.target>\\\\n    <maven.compiler.source>1.8</maven.compiler.source>\\\\n  </properties>\\\\n\`\`\`\\\\n\\\\nNow, right click on the project name in the _Project Explorer_ and click on _Maven > Update Project_. Click _OK_ in the dialog box that pops up.\\\\n\\\\nIn the _Project Explorer_, You should see the _JRE System library_ changing from **JavaSE-1.5** to **JavaSE-1.8**.\\\\n\\\\n![](https://imgur.com/7Pvq9hJ.png)\\\\n\\\\n## Add Web3j library to our project\\\\n\\\\nIn this step, we import the latest version of Web3j to our project via maven.\\\\n\\\\nIn Eclipse, edit the file \`pom.xml\` and add the following lines before \`</project>\`:\\\\n\\\\n\`\`\`xml\\\\n  <dependencies>\\\\n    <dependency>\\\\n      <groupId>org.web3j</groupId>\\\\n      <artifactId>core</artifactId>\\\\n      <version>4.3.0</version>\\\\n    </dependency>\\\\n  </dependencies>\\\\n\`\`\`\\\\n\\\\n_Full pom.xml file available [here](https://github.com/gjeanmart/kauri-content/blob/master/java-ethereum/pom.xml)_\\\\n\\\\nSave file and dependencies will import. In your package explorer you will see a Maven dependencies folder with all the JAR (Java ARchive) packages for web3j and its dependencies.\\\\n\\\\n## Create a Main class\\\\n\\\\nNow, we have all the required dependencies to use Web3j, we can start coding our Ethereum Java program.\\\\n\\\\nCreate a Java class \`Main.java\` in your project by right-clicking on the project and selecting _New > Class_.\\\\nEnter the package name \`io.kauri.tutorials.java_ethereum\`, the class name \`Main\` and check _public static void main(String\\\\\\\\[] args)_.\\\\n\\\\n![](https://imgur.com/iipSbO0.png)\\\\n\\\\nClick on _Finish_ to generate the skeleton file.\\\\n\\\\n\`\`\`java\\\\n//Main.java\\\\npackage io.kauri.tutorials.java_ethereum;\\\\n\\\\npublic class Main {\\\\n  public static void main(String[] args) {\\\\n    // TODO Auto-generated method stub\\\\n  }\\\\n}\\\\n\`\`\`\\\\n\\\\n## Connect to an Ethereum node with Web3j.\\\\n\\\\nNow we have created our project, imported the Web3j library and prepared a program to run our code. We can now connect to an Ethereum node and start executing operations over the JSON-RPC API abstracted by Web3j.\\\\n\\\\n### 1. Add imports\\\\n\\\\nFirst import the packages needed for our code, or allow your IDE to automatically import them for you:\\\\n\\\\n\`\`\`java\\\\nimport java.io.IOException;\\\\nimport org.web3j.protocol.Web3j;\\\\nimport org.web3j.protocol.http.HttpService;\\\\nimport org.web3j.protocol.core.methods.response.EthBlockNumber;\\\\nimport org.web3j.protocol.core.methods.response.EthGasPrice;\\\\nimport org.web3j.protocol.core.methods.response.Web3ClientVersion;\\\\n\`\`\`\\\\n\\\\n### 2. Connect to the node\\\\n\\\\nTo connect to the node, Web3j requires the JSON-RPC API endpoint:\\\\n\\\\n\`\`\`java\\\\nWeb3j web3 = Web3j.build(new HttpService(\\\\\\"<NODE ENDPOINT>\\\\\\"));\\\\n\`\`\`\\\\n\\\\n#### Local Ethereum node or ganache-cli\\\\n\\\\nIf you are running locally a [Geth](https://geth.ethereum.org/), [Parity](https://www.parity.io/), [Pantheon](https://github.com/PegaSysEng/pantheon) client or [ganache-cli](https://github.com/trufflesuite/ganache-cli). Your node JSON-RPC API endpoint is \`http://localhost:8545\` by default\\\\n\\\\n\`\`\`java\\\\nWeb3j web3 = Web3j.build(new HttpService(\\\\\\"http://localhost:8545\\\\\\"));\\\\n\`\`\`\\\\n\\\\n#### Ganache application: Local development blockchain\\\\n\\\\nIf you are running the [Ganache](https://www.trufflesuite.com/ganache) application on your machine. Your node JSON-RPC API endpoint is \`http://localhost:7545\` by default. _ganche-cli uses port 8545_\\\\n\\\\n\`\`\`java\\\\nWeb3j web3 = Web3j.build(new HttpService(\\\\\\"http://localhost:7545\\\\\\"));\\\\n\`\`\`\\\\n\\\\n_Note: As a test network, Ganache doesn't support all the JSON-RPC API operations specified, for example \`net_peercount\`._\\\\n\\\\n#### Infura: Hosted nodes for public mainet and testnets\\\\n\\\\nIf you use [Infura](https://infura.io). The node JSON-RPC API endpoint is \`https://<network>.infura.io/v3/<project key>\`.\\\\n\\\\n\`\`\`java\\\\nWeb3j web3 = Web3j.build(new HttpService(\\\\\\"https://mainnet.infura.io/v3/<project key>\\\\\\"));\\\\n\`\`\`\\\\n\\\\n### 3. Execute API operations\\\\n\\\\nWeb3j implements a JSON-RPC API client for Ethereum which can be used in the following way \`<response> = web3.<operation>.send()\`. For example:\\\\n\\\\n\`\`\`java\\\\ntry {\\\\n  // web3_clientVersion returns the current client version.\\\\n  Web3ClientVersion clientVersion = web3.web3ClientVersion().send();\\\\n\\\\n  //eth_blockNumber returns the number of most recent block.\\\\n  EthBlockNumber blockNumber = web3.ethBlockNumber().send();\\\\n\\\\n  //eth_gasPrice, returns the current price per gas in wei.\\\\n  EthGasPrice gasPrice =  web3.ethGasPrice().send();\\\\n\\\\n} catch(IOException ex) {\\\\n  throw new RuntimeException(\\\\\\"Error whilst sending json-rpc requests\\\\\\", ex);\\\\n}\\\\n\`\`\`\\\\n\\\\n**Note:** Serilization of the JSON-RPC request can raise an \`IOException\` exception, so you need to handle it.\\\\n\\\\n## Result\\\\n\\\\nThe following code shows the entire Java program which connects to an Ethereum node and runs some JSON-RPC calls.\\\\n\\\\n\`\`\`java\\\\n//Main.java\\\\npackage io.kauri.tutorials.java_ethereum;\\\\n\\\\nimport java.io.IOException;\\\\n\\\\nimport org.web3j.protocol.Web3j;\\\\nimport org.web3j.protocol.core.methods.response.EthBlockNumber;\\\\nimport org.web3j.protocol.core.methods.response.EthGasPrice;\\\\nimport org.web3j.protocol.core.methods.response.Web3ClientVersion;\\\\nimport org.web3j.protocol.http.HttpService;\\\\n\\\\npublic class Main {\\\\n\\\\n  public static void main(String[] args) {\\\\n    System.out.println(\\\\\\"Connecting to Ethereum ...\\\\\\");\\\\n    Web3j web3 = Web3j.build(new HttpService(\\\\\\"http://localhost:8545\\\\\\"));\\\\n    System.out.println(\\\\\\"Successfuly connected to Ethereum\\\\\\");\\\\n\\\\n    try {\\\\n      // web3_clientVersion returns the current client version.\\\\n      Web3ClientVersion clientVersion = web3.web3ClientVersion().send();\\\\n\\\\n      // eth_blockNumber returns the number of most recent block.\\\\n      EthBlockNumber blockNumber = web3.ethBlockNumber().send();\\\\n\\\\n      // eth_gasPrice, returns the current price per gas in wei.\\\\n      EthGasPrice gasPrice = web3.ethGasPrice().send();\\\\n\\\\n      // Print result\\\\n      System.out.println(\\\\\\"Client version: \\\\\\" + clientVersion.getWeb3ClientVersion());\\\\n      System.out.println(\\\\\\"Block number: \\\\\\" + blockNumber.getBlockNumber());\\\\n      System.out.println(\\\\\\"Gas price: \\\\\\" + gasPrice.getGasPrice());\\\\n\\\\n    } catch (IOException ex) {\\\\n      throw new RuntimeException(\\\\\\"Error whilst sending json-rpc requests\\\\\\", ex);\\\\n    }\\\\n  }\\\\n}\\\\n\`\`\`\\\\n\\\\n_Full file available [here](https://github.com/gjeanmart/kauri-content/blob/master/java-ethereum/src/main/java/io/kauri/tutorials/java_ethereum/Main.java)_\\\\n\\\\nTo run the program, right-click on the file \`Main.java\` and click on _Run As > Java Application_. You should see in the console the following result.\\\\n\\\\n\`\`\`shell\\\\nConnecting to Ethereum ...\\\\nSuccessfuly connected to Ethereum\\\\nClient version: Geth/v1.8.22-omnibus-260f7fbd/linux-amd64/go1.11.1\\\\nBlock number: 7983049\\\\nGas price: 3000000000\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/MWJqowg.gif)\\\\n\\\\n## References\\\\n\\\\n-   [GitHub Project code](https://github.com/gjeanmart/kauri-content/tree/master/java-ethereum)\\\\n-   [Web3j website](https://web3j.io/)\\\\n-   [Web3j documentation](https://web3j.readthedocs.io/en/latest/)\\\\n-   [Web3j Github repo](https://github.com/web3j/web3j)\\\\n-   [Ethereum JSON-RPC API](https://github.com/ethereum/wiki/wiki/JSON-RPC)\\\\n\\\\n\\\\n-----------------------------\\\\n\\\\n**Next Steps:**\\\\n\\\\n- [Manage an Ethereum account with Java and Web3j](https://kauri.io/article/925d923e12c543da9a0a3e617be963b4)\\\\n- [Generate a Java Wrapper from your Smart Contract](https://kauri.io/article/84475132317d4d6a84a2c42eb9348e4b)\\\\n- [Interacting with an Ethereum Smart Contract in Java](https://kauri.io/article/14dc434d11ef4ee18bf7d57f079e246e)\\\\n- [Listening for Ethereum Smart Contract Events in Java](https://kauri.io/article/760f495423db42f988d17b8c145b0874)\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\\\n\\"}",
          "contentHash": "QmdCsaJm7ajyh3ZyxacmSc94FFoBgSPWeWJLLYTCEMUUxf",
          "contributors": Array [
            Object {
              "__typename": "PublicUserDTO",
              "avatar": "https://api.dev.kauri.io:443/ipfs/QmXa9LzhDV4wiF9YLsv2Z9CBUaSU6ph8QLNRLTDAUBsrA8",
              "id": "f0f15cedc719b5a55470877b0710d5c7816916b1",
              "name": "Grégoire Jeanmart",
              "username": "gregjeanmart",
            },
          ],
          "dateCreated": "2019-07-19T15:40:19.256Z",
          "datePublished": "2019-07-19T15:40:22.354Z",
          "description": "Other articles in this series: - Manage an Ethereum account with Java and Web3j - Generate a Java Wrapper from your Smart Contract - Interacting with an Ethereum Smart Contract in Java - Listening for Ethereum Smart Contract Events in Java - Using Pantheon, the Java Ethereum Client with Linux Ethereum is a Blockchain, which means it operates on a peer-to-peer network composed of thousand of nodes where each node agrees on the next state. In order to interact with the Ethereum global state (distr",
          "id": "b9eb647c47a546bc95693acc0be72546",
          "owner": Object {
            "__typename": "CommunityDTO",
            "avatar": "https://api.kauri.io:443/ipfs/QmQ9to7bfbR6ADTG2tAKVxWTNw8o3YbwJ1LzdpEJeanLBX",
            "id": "5d2f30daaba2920001c82409",
            "name": "Java Ethereum",
            "resourceIdentifier": Object {
              "__typename": "ResourceIdentifier",
              "id": "5d2f30daaba2920001c82409",
              "type": "COMMUNITY",
            },
          },
          "resourceIdentifier": Object {
            "__typename": "ResourceIdentifier",
            "id": "b9eb647c47a546bc95693acc0be72546",
            "type": "ARTICLE",
            "version": 2,
          },
          "status": "PUBLISHED",
          "tags": Array [
            "ethereum",
            "java",
            "maven",
            "web3j",
            "json-rpc",
            "eclipse",
          ],
          "title": "Connecting to an Ethereum client with Java, Eclipse and Web3j",
          "updateComment": null,
          "version": 2,
          "voteResult": Object {
            "__typename": "VoteResultDTO",
            "count": 0,
            "hasVoted": null,
            "quantity": Object {},
            "sum": 0,
          },
        },
        Object {
          "__typename": "ArticleDTO",
          "associatedNfts": null,
          "attributes": Object {
            "background": "https://api.kauri.io:443/ipfs/QmTyEg3Lq2Bf2anauJnHcGtHiAJZ71kAbY2quL7jXZeWkh",
          },
          "author": Object {
            "__typename": "PublicUserDTO",
            "avatar": "https://api.dev.kauri.io:443/ipfs/QmXa9LzhDV4wiF9YLsv2Z9CBUaSU6ph8QLNRLTDAUBsrA8",
            "id": "f0f15cedc719b5a55470877b0710d5c7816916b1",
            "name": "Grégoire Jeanmart",
            "username": "gregjeanmart",
          },
          "authorId": "f0f15cedc719b5a55470877b0710d5c7816916b1",
          "checkpoint": null,
          "comments": Object {
            "__typename": "ResponsePage_CommentDTO",
            "content": Array [],
            "totalElements": 0,
            "totalPages": 0,
          },
          "content": "{\\"markdown\\":\\"**Other articles in this series:**\\\\n- [Connecting to an Ethereum client with Java, Eclipse and Web3j](https://kauri.io/article/b9eb647c47a546bc95693acc0be72546)\\\\n- [Generate a Java Wrapper from your Smart Contract](https://kauri.io/article/84475132317d4d6a84a2c42eb9348e4b)\\\\n- [Interacting with an Ethereum Smart Contract in Java](https://kauri.io/article/14dc434d11ef4ee18bf7d57f079e246e)\\\\n- [Listening for Ethereum Smart Contract Events in Java](https://kauri.io/article/760f495423db42f988d17b8c145b0874)\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\\\n\\\\n-------------------------------------------\\\\n\\\\nThe Ethereum blockchain is often compared to a World Computer with a global state. The global state grows after each new block and cosists of many accounts organised in a [Merkle tree](https://en.wikipedia.org/wiki/Merkle_tree).\\\\n\\\\n![](https://imgur.com/iQLdaOW.png)\\\\n\\\\nEach account has a state composed of information such as balance, nonce, storageRoot and codeHash, and is identified by a 20 bytes address (for example: \`0x66aac71c0c81ec00aebead84914a10e307a4cbf9\`).\\\\n\\\\nThere are two types of accounts:\\\\n\\\\n-   **Externally owned accounts**, which are controlled by private keys and have no code associated with them.\\\\n-   **Contract accounts**, which are controlled by their contract code and have code associated with them.\\\\n\\\\n![](https://imgur.com/3dlka35.png)\\\\n\\\\nIn this tutorial, we focus on externally owned accounts and how to retrieve information such as a balance, create or open an account and send transactions to another account using the Java library [Web3j](https://web3j.io/).\\\\n\\\\n## 1. Retrieve public information about an account\\\\n\\\\nThe Ethereum blockchain is a public shared ledger which we can query to retrieve information about the state at a different time, or block number.\\\\n\\\\n### Get account's balance\\\\n\\\\nEvery account has a balance of the Ethereum native cryptocurrency called **Ether**. Using our Web3j instance (see [article-1](#)), it is possible to retrieve the balance of an account at a given block using the function \`web3.ethGetBalance(<accountAddress>, <blockNo>).send()\`\\\\n\\\\nThe balance is stored by default in the smallest denomination of ether called _wei_ (1 ether = 10^18 wei) but Web3j provides a convenience utility class \`Convert\` to convert values between different units.\\\\n\\\\n-   Retrieve the latest balance (latest block) of an account:\\\\n\\\\n\`\`\`java\\\\nEthGetBalance balanceWei = web3.ethGetBalance(\\\\\\"0xF0f15Cedc719B5A55470877B0710d5c7816916b1\\\\\\", DefaultBlockParameterName.LATEST).send();\\\\nSystem.out.println(\\\\\\"balance in wei: \\\\\\" + balanceWei);\\\\n\\\\nBigDecimal balanceInEther = Convert.fromWei(balanceWei.getBalance().toString(), Unit.ETHER);\\\\nSystem.out.println(\\\\\\"balance in ether: \\\\\\" + balanceInEther);\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/S7w0eEH.png)\\\\n\\\\nIn the example above, the latest balance of the account \`0xF0f15Cedc719B5A55470877B0710d5c7816916b1\` is _33.25 ether_.\\\\n\\\\n-   Retrieve the balance of an account at a specific block, if the blockchain you connect to has generated any blocks so far. Test chains may not have yet:\\\\n\\\\n\`\`\`java\\\\nEthGetBalance balance = web3.ethGetBalance(\\\\\\"0xF0f15Cedc719B5A55470877B0710d5c7816916b1\\\\\\", new DefaultBlockParameterNumber(3000000)).send();\\\\n\\\\nBigDecimal balanceInEther = Convert.fromWei(balance.getBalance().toString(), Unit.ETHER);\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/PuUtKHV.png)\\\\n\\\\nThe balance at block #3,000,000 of the account \`0xF0f15Cedc719B5A55470877B0710d5c7816916b1\` is _8.12 ethers_.\\\\n\\\\n### Get account's nonce\\\\n\\\\nAlso included in the state of an account is the _nonce_, a sequence number symbolizing the number of transactions performed by an account.\\\\n\\\\nWeb3j provides the method \`web3.ethGetTransactionCount(<accountAddress>, <blockNo>).send()\` to retrieve the nonce at a given block number, in this case the most recent block.\\\\n\\\\n\`\`\`java\\\\nEthGetTransactionCount ethGetTransactionCount = web3.ethGetTransactionCount(\\\\\\"0xF0f15Cedc719B5A55470877B0710d5c7816916b1\\\\\\", DefaultBlockParameterName.LATEST).send();\\\\n\\\\nBigInteger nonce =  ethGetTransactionCount.getTransactionCount();\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/uJ2bcNk.png)\\\\n\\\\n## 2. Open or create an account\\\\n\\\\nIn order to control an externally owned account and the fund allocated on it, the 32 bytes **Private Key** associated to an account is needed. A private key is a confidential piece of information, so it usually doesn't come in clear text like \`3a1076bf45ab87712ad64ccb3b10217737f7faacbf2872e88fdd9a537d8fe266\` but is secured and encrypted in a wallet. There are many forms of wallets (more or less secured and practical):\\\\n\\\\n![](https://imgur.com/N74l0TI.png)\\\\n\\\\n![](https://imgur.com/m4JjJsM.png)\\\\n\\\\n![](https://imgur.com/X8mANUY.png)\\\\n\\\\nIn this section, we learn how to load an existing wallet and create a new one with Web3j to instanciate a \`Credentials\` object which we can use to sign and send transactions securely on the Ethereum blockchain.\\\\n\\\\n### Load a wallet\\\\n\\\\n#### From a JSON encryted keystore\\\\n\\\\nThe first form of wallet is the JSON encryted keystore, which is a password-encrypted version of the private key. This is the most standard way used by clients such as [Pantheon](https://pegasys.tech/) or [Geth](https://geth.ethereum.org/), but also by online tools like [MyEtherWallet](https://www.myetherwallet.com/) to secure a private key from potential attackers.\\\\n\\\\nWeb3j provides a utility class called \`WalletUtils\` to load a wallet into a \`Credentials\` object (wrapper containing the account address and the keypair).\\\\n\\\\n\`\`\`java\\\\nString walletPassword = \\\\\\"secr3t\\\\\\";\\\\nString walletDirectory = \\\\\\"/path/to/wallets\\\\\\";\\\\nString walletName = \\\\\\"UTC--2019-06-20T08-55-56.200000000Z--fd7d68e16ef61868f3e325fafdf2fc1ec0b77649.json\\\\\\";\\\\n\\\\n// Load the JSON encryted wallet\\\\nCredentials credentials = WalletUtils.loadCredentials(walletPassword, walletDirectory + \\\\\\"/\\\\\\" + walletName);\\\\n\\\\n// Get the account address\\\\nString accountAddress = credentials.getAddress();\\\\n\\\\n// Get the unencrypted private key into hexadecimal\\\\nString privateKey = credentials.getEcKeyPair().getPrivateKey().toString(16);\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/p92p616.png)\\\\n\\\\n#### From a Mnemonic phrase\\\\n\\\\nAnother common form of private key is the **Mnemonic sentence** (or seed phrase) which converts the 32 bytes key to a group of 12 easy to remember words. For example: \`candy maple cake sugar pudding cream honey rich smooth crumble sweet treat\`. This form was established by Bitcoin under the proposal [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).\\\\n\\\\nA mnemonic controls multiple private keys because of a mechanism to derive deterministically the mnemonic from a path.\\\\n\\\\nWe can optionally encrypt the mnemonic with a password.\\\\n\\\\n\`\`\`java\\\\nString password = null; // no encryption\\\\nString mnemonic = \\\\\\"candy maple cake sugar pudding cream honey rich smooth crumble sweet treat\\\\\\";\\\\n\\\\nCredentials credentials = WalletUtils.loadBip39Credentials(password, mnemonic);\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/xN2Ruaj.png)\\\\n\\\\nBy default, Web3j uses a derivation path equal to \`m/44'/60'/0'/1\` (read [this article](https://medium.com/myetherwallet/hd-wallets-and-derivation-paths-explained-865a643c7bf2) to understand _derivation path_). However, it is possible to open another account on a different path:\\\\n\\\\n\`\`\`java\\\\nString password = null; // no encryption\\\\nString mnemonic = \\\\\\"candy maple cake sugar pudding cream honey rich smooth crumble sweet treat\\\\\\";\\\\n\\\\n//Derivation path wanted: // m/44'/60'/0'/0\\\\nint[] derivationPath = {44 | Bip32ECKeyPair.HARDENED_BIT, 60 | Bip32ECKeyPair.HARDENED_BIT, 0 | Bip32ECKeyPair.HARDENED_BIT, 0,0};\\\\n\\\\n// Generate a BIP32 master keypair from the mnemonic phrase\\\\nBip32ECKeyPair masterKeypair = Bip32ECKeyPair.generateKeyPair(MnemonicUtils.generateSeed(mnemonic, password));\\\\n\\\\n// Derived the key using the derivation path\\\\nBip32ECKeyPair  derivedKeyPair = Bip32ECKeyPair.deriveKeyPair(masterKeypair, derivationPath);\\\\n\\\\n// Load the wallet for the derived key\\\\nCredentials credentials = Credentials.create(derivedKeyPair);\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/eEgEdOY.png)\\\\n\\\\n#### From a Private key\\\\n\\\\nAs mentioned before, a private key is a 32 bytes long number. To parse a private key with Web3j, we need to pass the private key to the class \`Credentials\`.\\\\n\\\\n\`\`\`java\\\\nString pk = \\\\\\"c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3\\\\\\";\\\\n\\\\nCredentials credentials = Credentials.create(pk);\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/svlvLnF.png)\\\\n\\\\n### Create a wallet\\\\n\\\\nFinally, if we don't already have an account and want to create a new one from scratch. Web3j's \`WalletUtils\` offers a method to create a JSON encrypted keystore.\\\\n\\\\n\`\`\`java\\\\nString walletPassword = \\\\\\"secr3t\\\\\\";\\\\nString walletDirectory = \\\\\\"/path/to/destination/\\\\\\";\\\\n\\\\nString walletName = WalletUtils.generateNewWalletFile(password, new File(directory));\\\\nSystem.out.println(\\\\\\"wallet location: \\\\\\" + directory + \\\\\\"/\\\\\\" + walletName);\\\\n\\\\n\\\\nCredentials credentials = WalletUtils.loadCredentials(password, directory + \\\\\\"/\\\\\\" + walletName);\\\\n\\\\nString accountAddress = credentials.getAddress();\\\\nSystem.out.println(\\\\\\"Account address: \\\\\\" + credentials.getAddress());\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/kbcemsH.png)\\\\n\\\\n## 3. Send a transaction\\\\n\\\\nNow we have learned how to retrieve public information (state), like the balance from an account and how to open an account using different methods, we can send a transaction to another account.\\\\n\\\\nA transaction on the Ethereum blockchain is composed of the following information:\\\\n\\\\n-   **nonce:** a count of the number of transaction sent by the sender.\\\\n-   **gasPrice (in wei):** the amount the sender is willing to pay per unit of gas required to execute the transaction.\\\\n-   **gasLimit:** the maximum amount of gas the sender is willing to pay to execute this transaction.\\\\n-   **to:** The address of the recipient account.\\\\n-   **value (in wei):** the amount of Wei to transfer from the sender to the recipient. In a contract-creating transaction, this value serves as the starting balance within the newly created contract account.\\\\n-   **signature:** Cryptographic signature that identified the sender of the transaction (from).\\\\n-   **data:** Optional field used to communicate with a smart contract (encoded string including the function name and the parameters).\\\\n\\\\nThere are two ways to send a transaction to the blockchain:\\\\n\\\\n-   **Via the Ethereum node:**\\\\n    This involves sending a non-signed transaction to the Ethereum client having the account _unlocked_.\\\\n    **_I personnaly don't recommend this method which might put your account at risk if the Ethereum node isn't correctly protected_**\\\\n\\\\n-   **Offline transaction:**\\\\n    The concept is to first construct the transaction object \`rawTransaction\` and sign it with a private key (Web3j Credential). Secondly send it to the Ethereum node via the JSON-RPC API to propagate across the network.\\\\n\\\\nOnce a transaction is broadcast to the network, a transaction hash is returned to the client but the transaction isn't performed yet. A set of miners/validators present on the network pick up all the pending transactions, group them into the next block and agree on the validity. Once verified, the transaction is mined into the new block. At this point, the client can claim a transaction receipt by transaction hash to aknowledge the good execution of his transaction.\\\\n\\\\n![](https://web3j.readthedocs.io/en/latest/_images/web3j_transaction.png)\\\\n\\\\n### Send funds from one account to another\\\\n\\\\n#### 1. Load an account and get the nonce\\\\n\\\\nAs explained in the previous sections, we need to load an account from one the methods and retrieve the nonce value of this account:\\\\n\\\\n\`\`\`java\\\\nString walletPassword = \\\\\\"secr3t\\\\\\";\\\\nString walletPath = \\\\\\"/path/to/wallet/UTC--2019-06-20T11-41-39.478000000Z--256c75c85f9c27ac5b2a22f085d9643f7ed91dc1.json\\\\\\";\\\\n\\\\n// Decrypt and open the wallet into a Credential object\\\\nCredentials credentials = WalletUtils.loadCredentials(walletPassword, walletPath);\\\\n\\\\n// Get nonce\\\\nEthGetTransactionCount ethGetTransactionCount = web3.ethGetTransactionCount(credentials.getAddress(), DefaultBlockParameterName.LATEST).send();\\\\nBigInteger nonce =  ethGetTransactionCount.getTransactionCount();\\\\n\`\`\`\\\\n\\\\n#### 2. Configure recipient account and amount to send\\\\n\\\\nIn the next step, we configure the amount (in Wei) to send to a recipient account.\\\\n\\\\n\`\`\`java\\\\n// Recipient account\\\\nString recipientAddress = \\\\\\"0xDD6325C45aE6fAbD028D19fa1539663Df14813a8\\\\\\";\\\\n\\\\n// Value to Transfer\\\\nBigInteger value = Convert.toWei(\\\\\\"1\\\\\\", Unit.ETHER).toBigInteger();\\\\n\`\`\`\\\\n\\\\n#### 3. Configure Gas parameters\\\\n\\\\nGas represents the fees of the network which taken by the miner who mines the block which includes your transaction.\\\\n\\\\nWhen sending a transaction, two parameters are important:\\\\n\\\\n-   **Gas Limit (in unit):** Gas limit refers to the maximum amount of gas you're willing to spend on a particular transaction. After the transaction is executed, if too much gas (\`gasLimit\`) was sent, the remaining gas is refunded to the sender.\\\\n\\\\n-   **Gas Price (in wei):** Amount of Ether you're willing to pay for every unit of gas\\\\n\\\\n\`\`\`java\\\\n// A transfer cost 21,000 units of gas\\\\nBigInteger gasLimit = BigInteger.valueOf(21000);\\\\n\\\\n// I am willing to pay 1Gwei (1,000,000,000 wei or 0.000000001 ether) for each unit of gas consumed by the transaction.\\\\nBigInteger gasPrice = Convert.toWei(\\\\\\"1\\\\\\", Unit.GWEI).toBigInteger();\\\\n\`\`\`\\\\n\\\\n#### 4. Prepare the raw transaction\\\\n\\\\nA raw transaction for a transfer of funds contains all the transaction data fields except:\\\\n\\\\n-   **data**: not a smart contract transaction\\\\n-   **signature**: signature not signed yet\\\\n\\\\n\`\`\`java\\\\n// Prepare the rawTransaction\\\\nRawTransaction rawTransaction  = RawTransaction.createEtherTransaction(\\\\n\\\\tnonce,\\\\n\\\\tgasPrice,\\\\n\\\\tgasLimit,\\\\n\\\\trecipientAddress,\\\\n\\\\tvalue);\\\\n\`\`\`\\\\n\\\\n#### 5. Signature\\\\n\\\\nThe signing part requires the \`rawTransaction\` as well as the \`credentials\` (keypair) used to cryptographically sign the transaction.\\\\n\\\\n\`\`\`java\\\\n// Sign the transaction\\\\nbyte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);\\\\n\\\\n// Convert it to Hexadecimal String to be sent to the node\\\\nString hexValue = Numeric.toHexString(signedMessage);\\\\n\`\`\`\\\\n\\\\n#### 6. Send to the node via JSON-RPC\\\\n\\\\nThe final step consists of sending the transaction signed to the node so it can be verified and broadcast to the network. In case of success, the method returns a response composed of the transaction hash.\\\\n\\\\n\`\`\`java\\\\n// Send transaction\\\\nEthSendTransaction ethSendTransaction = web3.ethSendRawTransaction(hexValue).send();\\\\n\\\\n// Get the transaction hash\\\\nString transactionHash = ethSendTransaction.getTransactionHash();\\\\n\`\`\`\\\\n\\\\n#### 7. Wait for the transaction to be mined.\\\\n\\\\nAs explained before, when the signed transaction is propagated to the network, depending on many factors (gas price, network congestion) it can take some time to see the transaction mined and added to the last block.\\\\n\\\\nThat's why the following code consists of a simple loop to verify every 3 seconds if the transaction is mined by calling the method \`web3.ethGetTransactionReceipt(<txhash>).send()\`.\\\\n\\\\n\`\`\`java\\\\n// Wait for transaction to be mined\\\\nOptional<TransactionReceipt> transactionReceipt = null;\\\\ndo {\\\\n  EthGetTransactionReceipt ethGetTransactionReceiptResp = web3.ethGetTransactionReceipt(transactionHash).send();\\\\n  transactionReceipt = ethGetTransactionReceiptResp.getTransactionReceipt();\\\\n\\\\n  Thread.sleep(3000); // Retry after 3 sec\\\\n} while(!transactionReceipt.isPresent());\\\\n\`\`\`\\\\n\\\\n#### Result\\\\n\\\\nHere is the full version of the code including everything explained in this article:\\\\n\\\\n\`\`\`java\\\\n// Transaction.java\\\\npackage io.kauri.tutorials.java_ethereum;\\\\n\\\\nimport java.io.IOException;\\\\nimport java.math.BigInteger;\\\\nimport java.util.Optional;\\\\n\\\\nimport org.web3j.crypto.Credentials;\\\\nimport org.web3j.crypto.RawTransaction;\\\\nimport org.web3j.crypto.TransactionEncoder;\\\\nimport org.web3j.protocol.Web3j;\\\\nimport org.web3j.protocol.core.DefaultBlockParameterName;\\\\nimport org.web3j.protocol.core.methods.response.EthGetTransactionCount;\\\\nimport org.web3j.protocol.core.methods.response.EthGetTransactionReceipt;\\\\nimport org.web3j.protocol.core.methods.response.EthSendTransaction;\\\\nimport org.web3j.protocol.core.methods.response.TransactionReceipt;\\\\nimport org.web3j.protocol.http.HttpService;\\\\nimport org.web3j.utils.Convert;\\\\nimport org.web3j.utils.Convert.Unit;\\\\nimport org.web3j.utils.Numeric;\\\\n\\\\npublic class Transaction {\\\\n\\\\n  public static void main(String[] args)  {\\\\n\\\\n    System.out.println(\\\\\\"Connecting to Ethereum ...\\\\\\");\\\\n    Web3j web3 = Web3j.build(new HttpService(\\\\\\"https://rinkeby.infura.io/v3/083836b2784f48e19e03487eb3209923\\\\\\"));\\\\n    System.out.println(\\\\\\"Successfuly connected to Ethereum\\\\\\");\\\\n\\\\n    try {\\\\n      String pk = \\\\\\"CHANGE_ME\\\\\\"; // Add a private key here\\\\n\\\\n      // Decrypt and open the wallet into a Credential object\\\\n      Credentials credentials = Credentials.create(pk);\\\\n      System.out.println(\\\\\\"Account address: \\\\\\" + credentials.getAddress());\\\\n      System.out.println(\\\\\\"Balance: \\\\\\" + Convert.fromWei(web3.ethGetBalance(credentials.getAddress(), DefaultBlockParameterName.LATEST).send().getBalance().toString(), Unit.ETHER));\\\\n\\\\n      // Get the latest nonce\\\\n      EthGetTransactionCount ethGetTransactionCount = web3.ethGetTransactionCount(credentials.getAddress(), DefaultBlockParameterName.LATEST).send();\\\\n      BigInteger nonce =  ethGetTransactionCount.getTransactionCount();\\\\n\\\\n      // Recipient address\\\\n      String recipientAddress = \\\\\\"0xAA6325C45aE6fAbD028D19fa1539663Df14813a8\\\\\\";\\\\n\\\\n      // Value to transfer (in wei)\\\\n      BigInteger value = Convert.toWei(\\\\\\"1\\\\\\", Unit.ETHER).toBigInteger();\\\\n\\\\n      // Gas Parameters\\\\n      BigInteger gasLimit = BigInteger.valueOf(21000);\\\\n      BigInteger gasPrice = Convert.toWei(\\\\\\"1\\\\\\", Unit.GWEI).toBigInteger();\\\\n\\\\n      // Prepare the rawTransaction\\\\n      RawTransaction rawTransaction  = RawTransaction.createEtherTransaction(\\\\n                 nonce,\\\\n                 gasPrice,\\\\n                 gasLimit,\\\\n                 recipientAddress,\\\\n                 value);\\\\n\\\\n      // Sign the transaction\\\\n      byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);\\\\n      String hexValue = Numeric.toHexString(signedMessage);\\\\n\\\\n      // Send transaction\\\\n      EthSendTransaction ethSendTransaction = web3.ethSendRawTransaction(hexValue).send();\\\\n      String transactionHash = ethSendTransaction.getTransactionHash();\\\\n      System.out.println(\\\\\\"transactionHash: \\\\\\" + transactionHash);\\\\n\\\\n      // Wait for transaction to be mined\\\\n      Optional<TransactionReceipt> transactionReceipt = null;\\\\n      do {\\\\n        System.out.println(\\\\\\"checking if transaction \\\\\\" + transactionHash + \\\\\\" is mined....\\\\\\");\\\\n            EthGetTransactionReceipt ethGetTransactionReceiptResp = web3.ethGetTransactionReceipt(transactionHash).send();\\\\n            transactionReceipt = ethGetTransactionReceiptResp.getTransactionReceipt();\\\\n            Thread.sleep(3000); // Wait 3 sec\\\\n      } while(!transactionReceipt.isPresent());\\\\n\\\\n      System.out.println(\\\\\\"Transaction \\\\\\" + transactionHash + \\\\\\" was mined in block # \\\\\\" + transactionReceipt.get().getBlockNumber());\\\\n      System.out.println(\\\\\\"Balance: \\\\\\" + Convert.fromWei(web3.ethGetBalance(credentials.getAddress(), DefaultBlockParameterName.LATEST).send().getBalance().toString(), Unit.ETHER));\\\\n\\\\n\\\\n    } catch (IOException | InterruptedException ex) {\\\\n      throw new RuntimeException(ex);\\\\n    }\\\\n  }\\\\n}\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/8XU21KA.gif)\\\\n\\\\nNow we understand the core principles behind sending transactions with Web3j, I can tell you a secret. Web3j provides a Utility class called 'Transfer' which takes care of everything (nonce, gas, transaction receipt polling, etc.) in one line of code.\\\\n\\\\n\`\`\`java\\\\nTransactionReceipt receipt = Transfer.sendFunds(web3, credentials, recipientAddress, BigDecimal.valueOf(1), Unit.ETHER).send();\\\\n\`\`\`\\\\n\\\\n## Summary\\\\n\\\\nIn this article, we learnt that the Ethereum Global State is composed of a mapping of all accounts states. We can query each account state can be queried to get information like the balance and the nonce.\\\\n\\\\nAn account is controlled by the person owning the private key of this account. The private key can have many forms and is usually secured in a wallet. Web3j allows to open a wallet from a JSON encrypted file, a mnemonic phrase or directly from the private key.\\\\n\\\\nTo send a transaction between two accounts, Web3j can generate a transaction oject, sign it and propagate it to the network to poll the Blockchain to get the transaction receipt when it's been mined.\\\\n\\\\n## Resources\\\\n\\\\n-   [Ethereum Unit converter (WEI, GWEI, ETHER, ....)](https://etherconverter.online/)\\\\n-   [Web3j Transaction doc](https://web3j.readthedocs.io/en/latest/transactions.html#transaction-signing-via-an-ethereum-client)\\\\n-   [Web3j RawTransaction Integration Tests](https://github.com/web3j/web3j/blob/master/integration-tests/src/test/java/org/web3j/protocol/scenarios/CreateRawTransactionIT.java)\\\\n-   [Ethereum - What is Gas Price and Limit](https://masterthecrypto.com/ethereum-what-is-gas-gas-limit-gas-price/)\\\\n-   [Diving into Ethereum World State](https://medium.com/cybermiles/diving-into-ethereums-world-state-c893102030ed)\\\\n\\\\n\\\\n-------------------------------------------\\\\n\\\\n**Next Steps:**\\\\n- [Generate a Java Wrapper from your Smart Contract](https://kauri.io/article/84475132317d4d6a84a2c42eb9348e4b)\\\\n- [Interacting with an Ethereum Smart Contract in Java](https://kauri.io/article/14dc434d11ef4ee18bf7d57f079e246e)\\\\n- [Listening for Ethereum Smart Contract Events in Java](https://kauri.io/article/760f495423db42f988d17b8c145b0874)\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\"}",
          "contentHash": "QmcN9cYEESs859Fkd2dEvfZNf6uy1VuuqZ6cS9dar3TnbK",
          "contributors": Array [
            Object {
              "__typename": "PublicUserDTO",
              "avatar": "https://api.dev.kauri.io:443/ipfs/QmXa9LzhDV4wiF9YLsv2Z9CBUaSU6ph8QLNRLTDAUBsrA8",
              "id": "f0f15cedc719b5a55470877b0710d5c7816916b1",
              "name": "Grégoire Jeanmart",
              "username": "gregjeanmart",
            },
          ],
          "dateCreated": "2019-07-19T15:42:45.466Z",
          "datePublished": "2019-07-19T15:42:48.882Z",
          "description": "Other articles in this series: - Connecting to an Ethereum client with Java, Eclipse and Web3j - Generate a Java Wrapper from your Smart Contract - Interacting with an Ethereum Smart Contract in Java - Listening for Ethereum Smart Contract Events in Java - Using Pantheon, the Java Ethereum Client with Linux The Ethereum blockchain is often compared to a World Computer with a global state. The global state grows after each new block and cosists of many accounts organised in a Merkle tree. Each ac",
          "id": "925d923e12c543da9a0a3e617be963b4",
          "owner": Object {
            "__typename": "CommunityDTO",
            "avatar": "https://api.kauri.io:443/ipfs/QmQ9to7bfbR6ADTG2tAKVxWTNw8o3YbwJ1LzdpEJeanLBX",
            "id": "5d2f30daaba2920001c82409",
            "name": "Java Ethereum",
            "resourceIdentifier": Object {
              "__typename": "ResourceIdentifier",
              "id": "5d2f30daaba2920001c82409",
              "type": "COMMUNITY",
            },
          },
          "resourceIdentifier": Object {
            "__typename": "ResourceIdentifier",
            "id": "925d923e12c543da9a0a3e617be963b4",
            "type": "ARTICLE",
            "version": 3,
          },
          "status": "PUBLISHED",
          "tags": Array [
            "ethereum",
            "java",
            "balance",
            "web3j",
            "account",
          ],
          "title": "Manage an Ethereum account with Java and Web3j",
          "updateComment": null,
          "version": 3,
          "voteResult": Object {
            "__typename": "VoteResultDTO",
            "count": 0,
            "hasVoted": null,
            "quantity": Object {},
            "sum": 0,
          },
        },
        Object {
          "__typename": "ArticleDTO",
          "associatedNfts": null,
          "attributes": Object {
            "background": "https://api.kauri.io:443/ipfs/QmTfBi56eSEH6PnX1fK7aYsQWv6Tq4mja1KH3Yxk8NFzJ5",
          },
          "author": Object {
            "__typename": "PublicUserDTO",
            "avatar": "https://api.dev.kauri.io:443/ipfs/QmXa9LzhDV4wiF9YLsv2Z9CBUaSU6ph8QLNRLTDAUBsrA8",
            "id": "f0f15cedc719b5a55470877b0710d5c7816916b1",
            "name": "Grégoire Jeanmart",
            "username": "gregjeanmart",
          },
          "authorId": "f0f15cedc719b5a55470877b0710d5c7816916b1",
          "checkpoint": null,
          "comments": Object {
            "__typename": "ResponsePage_CommentDTO",
            "content": Array [],
            "totalElements": 0,
            "totalPages": 0,
          },
          "content": "{\\"markdown\\":\\"\\\\n\\\\n**Other articles in this series:**\\\\n- [Connecting to an Ethereum client with Java, Eclipse and Web3j](https://kauri.io/article/b9eb647c47a546bc95693acc0be72546)\\\\n- [Manage an Ethereum account with Java and Web3j](https://kauri.io/article/925d923e12c543da9a0a3e617be963b4)\\\\n- [Interacting with an Ethereum Smart Contract in Java](https://kauri.io/article/14dc434d11ef4ee18bf7d57f079e246e)\\\\n- [Listening for Ethereum Smart Contract Events in Java](https://kauri.io/article/760f495423db42f988d17b8c145b0874)\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\\\n\\\\n-------------------------------------------\\\\n\\\\n\\\\nIn this article, we discover how to generate a [Java Wrapper Class](https://www.baeldung.com/java-wrapper-classes) directly from a smart contract to interact with a smart contract in Java.\\\\n\\\\nThere are different methods to generate a Java Wrapper Class from a Smart Contract:\\\\n\\\\n-   The [Web3j Command Line tool](https://web3j.readthedocs.io/en/latest/command_line.html) and solc\\\\n-   The Web3j Command Line tool and the artifacts generated by a Truffle build\\\\n-   The [web3j-maven-plugin](https://github.com/web3j/web3j-maven-plugin)\\\\n-   The [web3j-gradle-plugin](https://github.com/web3j/web3j-gradle-plugin)\\\\n\\\\nTo show how to use the methods above, this tutorial uses the following Smart Contract which notarizes documents into a registry on the Ethereum Blockchain.\\\\n\\\\n_DocumentRegistry.sol_\\\\n\\\\n\`\`\`solidity\\\\npragma solidity ^0.5.6;\\\\n\\\\n\\\\n/**\\\\n*  @dev Smart Contract responsible to notarize documents on the Ethereum Blockchain\\\\n*/\\\\ncontract DocumentRegistry {\\\\n\\\\n  struct Document {\\\\n      address signer; // Notary\\\\n      uint date; // Date of notarization\\\\n      bytes32 hash; // Document Hash\\\\n  }\\\\n\\\\n  /**\\\\n   *  @dev Storage space used to record all documents notarized with metadata\\\\n   */\\\\n  mapping(bytes32 => Document) registry;\\\\n\\\\n  /**\\\\n   *  @dev Notarize a document identified by its 32 bytes hash by recording the hash, the sender and date in the registry\\\\n   *  @dev Emit an event Notarized in case of success\\\\n   *  @param _documentHash Document hash\\\\n   */\\\\n  function notarizeDocument(bytes32 _documentHash) external returns (bool) {\\\\n    registry[_documentHash].signer = msg.sender;\\\\n    registry[_documentHash].date = now;\\\\n    registry[_documentHash].hash = _documentHash;\\\\n\\\\n    emit Notarized(msg.sender, _documentHash);\\\\n\\\\n    return true;\\\\n  }\\\\n\\\\n  /**\\\\n   *  @dev Verify a document identified by its hash was noterized in the registry.\\\\n   *  @param _documentHash Document hash\\\\n   *  @return bool if document was noterized previsouly in the registry\\\\n   */\\\\n  function isNotarized(bytes32 _documentHash) external view returns (bool) {\\\\n    return registry[_documentHash].hash ==  _documentHash;\\\\n  }\\\\n\\\\n  /**\\\\n   *  @dev Definition of the event triggered when a document is successfully notarized in the registry\\\\n   */\\\\n  event Notarized(address indexed _signer, bytes32 _documentHash);\\\\n}\\\\n\`\`\`\\\\n\\\\n## Method 1 - Web3j Command Line tool and solc\\\\n\\\\nThis first method generates the Smart contract ABI and bytecode from with \`solc\` and gives those two files as input to \`web3j-cli\` to generate the Wrapper.\\\\n\\\\n### 1. Install solc and verify the version\\\\n\\\\n[Install solc](https://solidity.readthedocs.io/en/develop/installing-solidity.html) and run the command below to make sure the solc version is greater than or equal to \`0.5.6\` (the version specified in the smart contract).\\\\n\\\\n\`\`\`shell\\\\n$ solc --version\\\\nsolc, the solidity compiler commandline interface\\\\nVersion: 0.5.9+commit.c68bc34e.Linux.g++\\\\n\`\`\`\\\\n\\\\n### 2. Install web3j-cli\\\\n\\\\nTo install the web3j-cli, download a zipfile/tarball from the [releases](https://github.com/web3j/web3j/releases/latest) page of the project repository, under the **Downloads** section, or for macOS users via [Homebrew](https://github.com/web3j/homebrew-web3j), or for Arch linux users via the [AUR](https://aur.archlinux.org/packages/web3j/).\\\\n\\\\n\`\`\`bash\\\\nbrew tap web3j/web3j\\\\nbrew install web3j\\\\nweb3j\\\\n\`\`\`\\\\n\\\\nTo run via a zipfile, extract it and run the binary, you may also want to add the binary to your \`PATH\`:\\\\n\\\\n\`\`\`shell\\\\n$ unzip web3j-4.3.0.zip\\\\n    creating: web3j-4.3.0/lib/\\\\n    inflating: web3j-4.3.0/lib/core-1.0.2-all.jar\\\\n    creating: web3j-4.3.0/bin/\\\\n    inflating: web3j-4.3.0/bin/web3j\\\\n    inflating: web3j-4.3.0/bin/web3j.bat\\\\n$ ./web3j-<version>/bin/web3j\\\\n\\\\n                _      _____ _     _\\\\n            | |    |____ (_)   (_)\\\\n__      _____| |__      / /_     _   ___\\\\n\\\\\\\\ \\\\\\\\ /\\\\\\\\ / / _ \\\\\\\\ '_ \\\\\\\\     \\\\\\\\ \\\\\\\\ |   | | / _ \\\\\\\\\\\\n\\\\\\\\ V  V /  __/ |_) |.___/ / | _ | || (_) |\\\\n    \\\\\\\\_/\\\\\\\\_/ \\\\\\\\___|_.__/ \\\\\\\\____/| |(_)|_| \\\\\\\\___/\\\\n                        _/ |\\\\n                        |__/\\\\n\\\\nUsage: web3j version|wallet|solidity ...\\\\n\`\`\`\\\\n\\\\n### 3. Compile the smart contract with solc\\\\n\\\\nGiven our Solidity file _DocumentRegistry.sol_, the \`solc <sol> --bin --abi --optimize -o <output>\` command compiles the smart contract and generates two new files in the same directory :\\\\n\\\\n\`\`\`shell\\\\n$ solc DocumentRegistry.sol --bin --abi --optimize -o ./\\\\nCompiler run successful. Artifact(s) can be found in directory ./.\\\\n\\\\n$ ls -l\\\\ntotal 12\\\\n-rw-rw-r-- 1 gjeanmart gjeanmart  565 Jun 24 13:42 DocumentRegistry.abi\\\\n-rw-rw-r-- 1 gjeanmart gjeanmart  676 Jun 24 13:42 DocumentRegistry.bin\\\\n-rw-rw-r-- 1 gjeanmart gjeanmart 1488 Jun 24 13:40 DocumentRegistry.sol\\\\n\`\`\`\\\\n\\\\n-   _DocumentRegistry.bin_: Binary file, bytecode of the smart contract\\\\n-   _DocumentRegistry.abi_: ABI (Application Binary Interface) of the smart contract which defines the interface in a JSON format.\\\\n\\\\n### 4. Generate the Wrapper with the web3j-cli\\\\n\\\\nUsing the ABI and bytecode (generated in step 3) and \`web3j-cli\` (installed during step 2), we can now generate our Smart contract Java Wrapper with the following command:\\\\n\\\\n\`\`\`shell\\\\nweb3j solidity generate -a=<abiFile> -b=<binFile> -o=<destinationFileDir> -p=<packageName>\\\\n\`\`\`\\\\n\\\\nFor example:\\\\n\\\\n\`\`\`shell\\\\n$ web3j solidity generate -a DocumentRegistry.abi  -b DocumentRegistry.bin -o . -p me.gjeanmart.tutorials.javaethereum.wrapper\\\\n\\\\n              _      _____ _     _\\\\n             | |    |____ (_)   (_)\\\\n__      _____| |__      / /_     _   ___\\\\n\\\\\\\\ \\\\\\\\ /\\\\\\\\ / / _ \\\\\\\\ '_ \\\\\\\\     \\\\\\\\ \\\\\\\\ |   | | / _ \\\\\\\\\\\\n \\\\\\\\ V  V /  __/ |_) |.___/ / | _ | || (_) |\\\\n  \\\\\\\\_/\\\\\\\\_/ \\\\\\\\___|_.__/ \\\\\\\\____/| |(_)|_| \\\\\\\\___/\\\\n                         _/ |\\\\n                        |__/\\\\n\\\\nGenerating me.gjeanmart.tutorials.javaethereum.wrapper.DocumentRegistry ... File written to .\\\\n\`\`\`\\\\n\\\\nAs a result, you should see the Java Wrapper file generated into the folder _<package-folders>/<contract>.java_ that you can copy to the _src/main/java/_ folder of your project.\\\\n\\\\n\`\`\`shell\\\\n./me/gjeanmart/tutorials/javaethereum/wrapper/DocumentRegistry.java\\\\n\`\`\`\\\\n\\\\n## Method 2 - Web3j Command Line tool and Truffle artefacts\\\\n\\\\n[**Truffle**](https://www.trufflesuite.com/truffle) is one of the most well-known frameworks to help you develop, test and deploy with Ethereum. We can use the artefacts that Truffle generates with the Web3j command line tool to create the wrapper class.\\\\n\\\\n### 1. Install Truffle\\\\n\\\\nTruffle is available as an npm package.\\\\n\\\\n\`\`\`shell\\\\n$ npm install truffle -g\\\\n- Fetching solc version list from solc-bin. Attempt #1\\\\n+ truffle@5.0.24\\\\nadded 27 packages from 439 contributors in 11.636s\\\\n\\\\n$ truffle version\\\\nTruffle v5.0.24 (core: 5.0.24)\\\\nSolidity v0.5.0 (solc-js)\\\\nNode v10.15.3\\\\nWeb3.js v1.0.0-beta.37\\\\n\`\`\`\\\\n\\\\n### 2. Initialize a new Truffle project\\\\n\\\\nTo initialize a Truffle project, use the command \`truffle init\` in a new folder. The command creates the folders _contracts/_, _migration/_ and _test/_, and the file _truffle-config.js_.\\\\n\\\\n\`\`\`shell\\\\n$ mkdir truffle\\\\n$ cd truffle\\\\n$ truffle init\\\\n\\\\n? Preparing to download\\\\n? Downloading\\\\n? Cleaning up temporary files\\\\n? Setting up box\\\\n\\\\nUnbox successful. Sweet!\\\\n\\\\nCommands:\\\\n\\\\n  Compile:        truffle compile\\\\n  Migrate:        truffle migrate\\\\n  Test contracts: truffle test\\\\n\\\\n$ ls -l\\\\ntotal 20\\\\ndrwxrwxr-x 2 gjeanmart gjeanmart 4096 Jun 24 14:25 contracts\\\\ndrwxrwxr-x 2 gjeanmart gjeanmart 4096 Jun 24 14:25 migrations\\\\ndrwxrwxr-x 2 gjeanmart gjeanmart 4096 Jun 24 14:25 test\\\\n-rw-rw-r-- 1 gjeanmart gjeanmart 4233 Jun 24 14:25 truffle-config.js\\\\n\`\`\`\\\\n\\\\n### 3. Add the contract into the folder \`contracts\`\\\\n\\\\nCopy the Smart Contract source _DocumentRegistry.sol_ into the folder _contracts_.\\\\n\\\\n### 4. Compile the contract\\\\n\\\\nCompile the smart contract with the command \`truffle compile\`, this command generates a new folder _build/contracts/_, containing a Truffle artefact for each Smart contract compiled.\\\\n\\\\n\`\`\`shell\\\\n$ truffle compile\\\\n\\\\nCompiling your contracts...\\\\n===========================\\\\n> Compiling ./contracts/DocumentRegistry.sol\\\\n> Compiling ./contracts/Migrations.sol\\\\n> Artifacts written to /home/gjeanmart/workspace/tutorials/java-ethereum-wrapper/truffle/build/contracts\\\\n> Compiled successfully using:\\\\n   - solc: 0.5.8+commit.23d335f2.Emscripten.clang\\\\n\\\\n$ ls -l build/contracts/\\\\ntotal 136\\\\n-rw-rw-r-- 1 gjeanmart gjeanmart 79721 Jun 24 14:33 DocumentRegistry.json\\\\n-rw-rw-r-- 1 gjeanmart gjeanmart 54043 Jun 24 14:33 Migrations.json\\\\n\`\`\`\\\\n\\\\n### 5. Generate the Smart Contract Java Wrapper from the Truffle Artefact\\\\n\\\\nFinally, web3j-cli provides a method to generate the Wrapper directly from the Truffle artefact result of \`truffle compile\` with the command:\\\\n\\\\n\`\`\`shell\\\\n$ web3j  truffle generate ./build/contracts/DocumentRegistry.json -o . -p me.gjeanmart.tutorials.javaethereum.wrapper\\\\n\\\\n              _      _____ _     _\\\\n             | |    |____ (_)   (_)\\\\n__      _____| |__      / /_     _   ___\\\\n\\\\\\\\ \\\\\\\\ /\\\\\\\\ / / _ \\\\\\\\ '_ \\\\\\\\     \\\\\\\\ \\\\\\\\ |   | | / _ \\\\\\\\\\\\n \\\\\\\\ V  V /  __/ |_) |.___/ / | _ | || (_) |\\\\n  \\\\\\\\_/\\\\\\\\_/ \\\\\\\\___|_.__/ \\\\\\\\____/| |(_)|_| \\\\\\\\___/\\\\n                         _/ |\\\\n                        |__/\\\\n\\\\nGenerating me.gjeanmart.tutorials.javaethereum.wrapper.DocumentRegistry ... File written to .\\\\n\`\`\`\\\\n\\\\nAs a result, you should see the Java Wrapper file generated into the folder _&lt;package_folders>/<contract>.java_ that you can copy to the _src/main/java/_ folder of your project.\\\\n\\\\n\`\`\`shell\\\\n./me/gjeanmart/tutorials/javaethereum/wrapper/DocumentRegistry.java\\\\n\`\`\`\\\\n\\\\n**Note**: With Truffle you can do a lot more than shown in this post, such as deployment scriptd (migration), Multi-network configuration, testing, debugging. I recommend reading [the following guide](https://kauri.io/collection/5b8e401ee727370001c942e3) to learn more about all the features.\\\\n\\\\n## Method 3 - web3j-maven-plugin\\\\n\\\\nThe next solution is more elegant than the previous two because we don't have to install the webj-cli and copy the file to the source folder. We can use this method directly inside a Java project using Maven and the [**web3j-maven-plugin**](https://github.com/web3j/web3j-maven-plugin). The following steps assume you have created a Maven project.\\\\n\\\\n### 1. Prerequisites\\\\n\\\\n[Install solc](https://solidity.readthedocs.io/en/develop/installing-solidity.html) and run the command below to make sure the solc version is greater than or equal to \`0.5.6\` (the version specified in the smart contract).\\\\n\\\\n\`\`\`shell\\\\n$ solc --version\\\\nsolc, the solidity compiler commandline interface\\\\nVersion: 0.5.9+commit.c68bc34e.Linux.g++\\\\n\`\`\`\\\\n\\\\n### 2. Copy the smart contract into the folder _src/main/resources_\\\\n\\\\nCopy the Smart Contract source _DocumentRegistry.sol_ into the _src/main/resources_ folder of the Maven project.\\\\n\\\\n### 3. Configure Maven to generate the Wrapper during the \`generate-sources\` phase\\\\n\\\\nIn this step, we configure two Maven plugins:\\\\n\\\\n#### web3j-maven-plugin\\\\n\\\\nThe first plugin does the same as the two previous methods but integrated with Maven. First we configure the plugin to execute automatically when entering the \`generate-sources\` phase of the project.\\\\n\\\\nSecondly we configure the plugin parameters:\\\\n\\\\n-   _packageName_: Package name to apply to the generated Wrapper classes\\\\n-   _sourceDestination_: Target destination folder to move the generated Wrapper classes\\\\n-   _soliditySourceFiles_: Where to find the Smart Contract source files\\\\n\\\\n#### build-helper-maven-plugin\\\\n\\\\nThe second plugin adds the _sourceDestination_ folder into the classpath so we can import the generated Wrapper classes\\\\n\\\\n_pom.xml_\\\\n\\\\n\`\`\`xml\\\\n<build>\\\\n    <plugins>\\\\n        <plugin>\\\\n            <groupId>org.web3j</groupId>\\\\n            <artifactId>web3j-maven-plugin</artifactId>\\\\n            <version>4.2.0</version>\\\\n            <executions>\\\\n                <execution>\\\\n                    <id>generate-sources-web3j</id>\\\\n                    <phase>generate-sources</phase>\\\\n                    <goals>\\\\n                        <goal>generate-sources</goal>\\\\n                    </goals>\\\\n                    <configuration>\\\\n                        <packageName>me.gjeanmart.tutorials.javaethereum.contracts.generated</packageName>\\\\n                        <sourceDestination>\${basedir}/target/generated-sources/contracts</sourceDestination>\\\\n                        <soliditySourceFiles>\\\\n                            <directory>\${basedir}/src/main/resources</directory>\\\\n                            <includes>\\\\n                                <include>**/*.sol</include>\\\\n                            </includes>\\\\n                        </soliditySourceFiles>\\\\n                    </configuration>\\\\n                </execution>\\\\n            </executions>\\\\n        </plugin>\\\\n\\\\n        <plugin>\\\\n            <groupId>org.codehaus.mojo</groupId>\\\\n            <artifactId>build-helper-maven-plugin</artifactId>\\\\n            <executions>\\\\n                <execution>\\\\n                    <id>add-source</id>\\\\n                    <phase>generate-sources</phase>\\\\n                    <goals>\\\\n                        <goal>add-source</goal>\\\\n                    </goals>\\\\n                    <configuration>\\\\n                        <sources>\\\\n                            <source>\${basedir}/target/generated-sources/contracts</source>\\\\n                        </sources>\\\\n                    </configuration>\\\\n                </execution>\\\\n            </executions>\\\\n        </plugin>\\\\n    </plugins>\\\\n</build>\\\\n\`\`\`\\\\n\\\\n### 4. Run Maven generate-sources\\\\n\\\\nFinally, build the Maven project by using, for example \`mvn clean package\` (including the generate-sources phase). As a result, we can see the Java Wrapper has been generated into \`/target/generated-sources/contracts/me/gjeanmart/tutorials/javaethereum/contracts/generated/DocumentRegistry.java\` and added to the classpath automatically.\\\\n\\\\n![](https://imgur.com/nBMOWGq.png)\\\\n\\\\n## Method 4 - web3j-gradle-plugin\\\\n\\\\nThe last method is similar to the previous method with Maven, but using Gradle instead.\\\\n\\\\n### 1. Prerequisites\\\\n\\\\n[Install solc](https://solidity.readthedocs.io/en/develop/installing-solidity.html) and run the command below to make sure the solc version is greater than or equal to \`0.5.6\` (the version specified in the smart contract).\\\\n\\\\n\`\`\`shell\\\\n$ solc --version\\\\nsolc, the solidity compiler commandline interface\\\\nVersion: 0.5.9+commit.c68bc34e.Linux.g++\\\\n\`\`\`\\\\n\\\\n### 2. Place the smart contract into the folder _src/main/solidity_\\\\n\\\\nCopy the Smart Contract source _DocumentRegistry.sol_ into the folder _src/main/solidity_ of the Gradle project.\\\\n\\\\n### 3. Configure Gradle to generate the Wrapper during build\\\\n\\\\nFirst import the web3j-gradle plugin into the _build.gradle_ file\\\\n\\\\n\`\`\`groovy\\\\nplugins {\\\\n    id 'org.web3j' version '4.3.0'\\\\n}\\\\n\`\`\`\\\\n\\\\nThen we can configure the plugin to specify the package name and the target folder for the generated wrapper classes:\\\\n\\\\n\`\`\`groovy\\\\nweb3j {\\\\n    generatedPackageName = 'me.gjeanmart.tutorials.javaethereum.contracts.generated'\\\\n    generatedFilesBaseDir = \\\\\\"$buildDir/contracts\\\\\\"\\\\n}\\\\n\`\`\`\\\\n\\\\nTo use your system installed version of \`solc\` instead of the version bundled with the plugin, add the following lines to _build.gradle_:\\\\n\\\\n\`\`\`groovy\\\\nsolidity {\\\\n    executable = \\\\\\"solc\\\\\\"\\\\n}\\\\n\`\`\`\\\\n\\\\n_build.gradle_\\\\n\\\\n\`\`\`groovy\\\\n/*\\\\n * This file was generated by the Gradle 'init' task.\\\\n *\\\\n * This generated file contains a sample Java Library project to get you started.\\\\n * For more details take a look at the Java Libraries chapter in the Gradle\\\\n * user guide available at https://docs.gradle.org/5.0/userguide/java_library_plugin.html\\\\n */\\\\n\\\\nplugins {\\\\n    // Apply the java-library plugin to add support for Java Library\\\\n    id 'java-library'\\\\n    id 'org.web3j' version '4.3.0'\\\\n}\\\\n\\\\nrepositories {\\\\n    // Use jcenter for resolving your dependencies.\\\\n    // You can declare any Maven/Ivy/file repository here.\\\\n    jcenter()\\\\n}\\\\n\\\\ndependencies {\\\\n    // This dependency is exported to consumers, that is to say found on their compile classpath.\\\\n    api 'org.apache.commons:commons-math3:3.6.1'\\\\n\\\\n    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\\\\n    implementation 'com.google.guava:guava:26.0-jre'\\\\n    implementation 'org.web3j:core:4.3.0'\\\\n\\\\n    // Use JUnit test framework\\\\n    testImplementation 'junit:junit:4.12'\\\\n}\\\\n\\\\nweb3j {\\\\n    generatedPackageName = 'me.gjeanmart.tutorials.javaethereum.contracts.generated'\\\\n    generatedFilesBaseDir = \\\\\\"$buildDir/contracts\\\\\\"\\\\n}\\\\n\\\\nsolidity {\\\\n    executable = \\\\\\"solc\\\\\\"\\\\n}\\\\n\`\`\`\\\\n\\\\n### 4. Execute gradle build\\\\n\\\\nIn this last step, we execute the build using \`./gradlew tasks --all\` and verify that our generated wrapper classes have been generated.\\\\n\\\\n![](https://imgur.com/dA0sVy1.png)\\\\n\\\\n\\\\n-------------------------------------------\\\\n\\\\n**Next Steps:**\\\\n- [Interacting with an Ethereum Smart Contract in Java](https://kauri.io/article/14dc434d11ef4ee18bf7d57f079e246e)\\\\n- [Listening for Ethereum Smart Contract Events in Java](https://kauri.io/article/760f495423db42f988d17b8c145b0874)\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\\\n\\"}",
          "contentHash": "QmQA9Ef7EpyQtbGuxxfL4z4YE5UqPPk7bkbgT1aQQV1Zt1",
          "contributors": Array [
            Object {
              "__typename": "PublicUserDTO",
              "avatar": "https://api.dev.kauri.io:443/ipfs/QmXa9LzhDV4wiF9YLsv2Z9CBUaSU6ph8QLNRLTDAUBsrA8",
              "id": "f0f15cedc719b5a55470877b0710d5c7816916b1",
              "name": "Grégoire Jeanmart",
              "username": "gregjeanmart",
            },
          ],
          "dateCreated": "2019-07-19T15:45:43.967Z",
          "datePublished": "2019-07-19T15:45:46.562Z",
          "description": "Other articles in this series: - Connecting to an Ethereum client with Java, Eclipse and Web3j - Manage an Ethereum account with Java and Web3j - Interacting with an Ethereum Smart Contract in Java - Listening for Ethereum Smart Contract Events in Java - Using Pantheon, the Java Ethereum Client with Linux In this article, we discover how to generate a Java Wrapper Class directly from a smart contract to interact with a smart contract in Java. There are different methods to generate a Java Wrappe",
          "id": "84475132317d4d6a84a2c42eb9348e4b",
          "owner": Object {
            "__typename": "CommunityDTO",
            "avatar": "https://api.kauri.io:443/ipfs/QmQ9to7bfbR6ADTG2tAKVxWTNw8o3YbwJ1LzdpEJeanLBX",
            "id": "5d2f30daaba2920001c82409",
            "name": "Java Ethereum",
            "resourceIdentifier": Object {
              "__typename": "ResourceIdentifier",
              "id": "5d2f30daaba2920001c82409",
              "type": "COMMUNITY",
            },
          },
          "resourceIdentifier": Object {
            "__typename": "ResourceIdentifier",
            "id": "84475132317d4d6a84a2c42eb9348e4b",
            "type": "ARTICLE",
            "version": 3,
          },
          "status": "PUBLISHED",
          "tags": Array [
            "smart-contract",
            "ethereum",
            "java",
            "web3j",
            "wrapper",
            "solidity",
          ],
          "title": "Generate a Java Wrapper from your Smart Contract",
          "updateComment": null,
          "version": 3,
          "voteResult": Object {
            "__typename": "VoteResultDTO",
            "count": 0,
            "hasVoted": null,
            "quantity": Object {},
            "sum": 0,
          },
        },
        Object {
          "__typename": "ArticleDTO",
          "associatedNfts": null,
          "attributes": Object {
            "background": "https://api.kauri.io:443/ipfs/QmQBqEvUaNN7ByVMSPrpa2Tw1mMGCCNPYyfai7Z6WE6Fwr",
          },
          "author": Object {
            "__typename": "PublicUserDTO",
            "avatar": "https://api.beta.kauri.io:443/ipfs/QmekAbiDvz3Bc5y4pZB7Gnk5Zgn5iaa5CxQoSmTsDoPkP9",
            "id": "4d91838268f6d6d4e590e8fd2a001cd91c32e7a4",
            "name": "Craig Williams",
            "username": "craig",
          },
          "authorId": "4d91838268f6d6d4e590e8fd2a001cd91c32e7a4",
          "checkpoint": null,
          "comments": Object {
            "__typename": "ResponsePage_CommentDTO",
            "content": Array [],
            "totalElements": 0,
            "totalPages": 0,
          },
          "content": "{\\"markdown\\":\\"\\\\n**Other articles in this series:**\\\\n- [Connecting to an Ethereum client with Java, Eclipse and Web3j](https://kauri.io/article/b9eb647c47a546bc95693acc0be72546)\\\\n- [Manage an Ethereum account with Java and Web3j](https://kauri.io/article/925d923e12c543da9a0a3e617be963b4)\\\\n- [Generate a Java Wrapper from your Smart Contract](https://kauri.io/article/84475132317d4d6a84a2c42eb9348e4b)\\\\n- [Listening for Ethereum Smart Contract Events in Java](https://kauri.io/article/760f495423db42f988d17b8c145b0874)\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\\\n\\\\n-------------------------------------------\\\\n\\\\nIn this tutorial, you will learn how to deploy a smart contract using the Web3j java library, along with how to interact with the functions of the smart contract.\\\\n\\\\nAs a prerequisite, you should be familiar with [account management](https://kauri.io/article/925d923e12c543da9a0a3e617be963b4/manage-an-ethereum-account-with-java-and-web3j) and contract java wrapper generation as described in the [previous article](https://kauri.io/article/84475132317d4d6a84a2c42eb9348e4b/generate-a-java-wrapper-from-your-smart-contract) in this series.  For continuity, we will deploy the same \`DocumentRegistry\` smart contract.\\\\n\\\\n_DocumentRegistry.sol_\\\\n\\\\n\`\`\` solidity\\\\npragma solidity ^0.5.6;\\\\n\\\\n\\\\n/**\\\\n*  @dev Smart Contract resposible to notarize documents on the Ethereum Blockchain\\\\n*/\\\\ncontract DocumentRegistry {\\\\n\\\\n    struct Document {\\\\n        address signer; // Notary\\\\n        uint date; // Date of notarization\\\\n        string hash; // Document Hash\\\\n    }\\\\n\\\\n    /**\\\\n     *  @dev Storage space used to record all documents notarized with metadata\\\\n     */\\\\n    mapping(bytes32 => Document) registry;\\\\n\\\\n    /**\\\\n     *  @dev Notarize a document identified by the hash of the document hash, the sender and date in the registry\\\\n     *  @dev Emit an event Notarized in case of success\\\\n     *  @param _documentHash Document hash\\\\n     */\\\\n    function notarizeDocument(string calldata _documentHash) external returns (bool) {\\\\n        bytes32 id = keccak256(abi.encodePacked(_documentHash));\\\\n\\\\n        registry[id].signer = msg.sender;\\\\n        registry[id].date = now;\\\\n        registry[id].hash = _documentHash;\\\\n\\\\n        emit Notarized(msg.sender, _documentHash);\\\\n\\\\n        return true;\\\\n    }\\\\n\\\\n    /**\\\\n     *  @dev Verify a document identified by its has was noterized in the registry previsouly.\\\\n     *  @param _documentHash Document hash\\\\n     *  @return bool if document was noterized previsouly in the registry\\\\n     */\\\\n    function isNotarized(string calldata _documentHash) external view returns (bool) {\\\\n        return registry[keccak256(abi.encodePacked(_documentHash))].signer != address(0);\\\\n    }\\\\n\\\\n    /**\\\\n     *  @dev Definition of the event triggered when a document is successfully notarized in the registry\\\\n     */\\\\n    event Notarized(address indexed _signer, string _documentHash);\\\\n}\\\\n\`\`\`\\\\n\\\\n## A Brief Primer on Mining and Gas\\\\n\\\\n### Mining\\\\n\\\\nAny interactions with the Ethereum network that update EVM state must be triggered by a transaction that is broadcast to the blockchain.  Some example interactions include sending Ether to another account, deploying a smart contract and some smart contract function invocations.\\\\n\\\\nMiners are entities that secure the Ethereum network by constantly attempting to calculate the answer to a complex mathematical puzzle, a mechanism called Proof-of-Work consensus.\\\\n\\\\nIt is the job of miners to gather a bundle of pending transactions (from the mempool) and create a block that includes these transactions.  Once a transaction is included within a mined block, it is considered executed, and any related state changes will be applied.\\\\n\\\\n### Gas\\\\n\\\\nEther, the native cryptocurrency of Ethereum, is paid by the transaction sender to the miner that included the transaction within a block.  This is one of the ways that miners are incentivized.\\\\n\\\\nGas is a unit of computational work within the Ethereum network, and the amount of Ether paid whilst executing a transaction depends on how much gas is consumed, along with the \`gasPrice\` transaction attribute, which defines how much Ether the sender will pay per gas unit consumed.  Its important to understand that different transactions will require differing amounts of gas, depending on the operation, with each transaction costing a minimum of 21,000 gas.\\\\n\\\\nIt is also possible to define the absolute maximum amount of gas that a transaction sender is willing to consume in order to execute the transaction, by specifying the \`gasLimit\` attribute.\\\\n\\\\n## Deploying\\\\n\\\\nThe ability to deploy immutable smart contracts that live indefinitely is the secret sauce of Ethereum!  Smart contracts are pieces of code with functions that can be executed by any interested parties.  They live as bytecode within the network but are usually written in a language such as [Solidity](https://solidity.readthedocs.io/en) or [Vyper](https://vyper.readthedocs.io), then encoded and deployed.\\\\n\\\\nBy far the easiest way to deploy the \`DocumentRegistry\` smart contract is to use a wrapper that has been generated by Web3j.   This wrapper provides a native java class representation of the smart contract.  Two (non deprecated) \`deploy\` methods that can be used to deploy the code to the Ethereum network are provided:\\\\n\\\\n\`\`\` java\\\\npublic static RemoteCall<DocumentRegistry> deploy(Web3j web3j, Credentials credentials, ContractGasProvider contractGasProvider)\\\\n\`\`\`\\\\n\`\`\` java\\\\npublic static RemoteCall<DocumentRegistry> deploy(Web3j web3j, TransactionManager transactionManager, ContractGasProvider contractGasProvider)\\\\n\`\`\`\\\\n\\\\nThe latter allows the \`TransactionManager\` to be specified; an object which controls how Web3j connects to an Ethereum client.  We're happy to use the default \`RawTransactionManager\` in this example, so we'll use the former method, which takes wallet \`Credentials\` as an argument.  We must also create a \`ContractGasProvider\`, which provides the gas price and gas limit for the transaction; indirectly specifying how much the contract will cost to deploy, in Ether.\\\\n\\\\n_DocumentRegistry Deployment Code_\\\\n\`\`\` java\\\\n//Create credentials from private key\\\\nCredentials creds = Credentials.create(\\\\\\"0x8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63\\\\\\");\\\\n\\\\nDocumentRegistry registryContract = DocumentRegistry.deploy(web3j, creds, new DefaultGasProvider()).send();\\\\n\\\\nString contractAddress = registryContract.getContractAddress();\\\\n\`\`\`\\\\nThe \`deploy\` method returns a \`RemoteCall\` object.  Calling \`send()\` on the \`RemoteCall\` synchronously deploys the smart contract to the Ethereum network, and returns an instance of \`DocumentRegistry\` which is linked to this deployed code.  Every deployed smart contract has a unique Ethereum address associated with it, and this address can be accessed by calling the \`getContractAddress()\` method on the contract wrapper, after deployment.\\\\n\\\\nIn this snippet, the credentials are constructed from a hard coded private key (for address 0xfe3b557e8fb62b89f4916b721be55ceb828dbd73).  This is fine for testing and demonstration purposes, but a production implementation should never hard code a private key, because an attacker will be able to take control of your account.  One approach to overcome this is to set the key as an environment variable on your server, and load this in your code.\\\\n\\\\nThe provided \`DefaultGasProvider\` is used in this example, which sets the gas price and limit to hard coded values, but a custom version can be built by implementing the below interface:\\\\n\\\\n\`\`\` java\\\\npublic interface ContractGasProvider {\\\\n    BigInteger getGasPrice(String contractFunc);\\\\n\\\\n    @Deprecated\\\\n    BigInteger getGasPrice();\\\\n\\\\n    BigInteger getGasLimit(String contractFunc);\\\\n\\\\n    @Deprecated\\\\n    BigInteger getGasLimit();\\\\n}\\\\n\`\`\`\\\\n\\\\n## Creating a Wrapper Instance for an Already Deployed Contract\\\\nMore often than not, the smart contract that you want to interact with will already be deployed to the Ethereum network.  In this scenario, the static \`load(..)\` method can be used:\\\\n\`\`\` java\\\\npublic static DocumentRegistry load(String contractAddress, Web3j web3j, Credentials credentials, ContractGasProvider contractGasProvider)\\\\n\`\`\`\\\\n\`\`\` java\\\\npublic static DocumentRegistry load(String contractAddress, Web3j web3j, TransactionManager transactionManager, ContractGasProvider contractGasProvider)\\\\n\`\`\`\\\\n\\\\nFor example, if our \`DocumentRegistry\` is deployed with the address \`0x10c7dc2b84b6c8e6df5a749655830e70adca3a2b\`, we can obtain a java wrapper for the deployed contract as follows:\\\\n\\\\n\`\`\` java\\\\n//Create credentials from private key\\\\nCredentials creds = Credentials.create(\\\\\\"0x8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63\\\\\\");\\\\n\\\\nDocumentRegistry registryContract = DocumentRegistry.load(web3j, creds, new DefaultGasProvider());\\\\n\`\`\`\\\\n## Invoking a Smart Contract Function\\\\n\\\\n### Transactions vs Calls\\\\n\\\\nA smart contract function can be invoked in 2 different ways, depending on the behaviour of the function.  \\\\n\\\\n#### Transactions\\\\n\\\\nTo invoke a smart contract function that can potentially change contract state (adding / updating / deleting a value), a transaction must be broadcast to the Ethereum network.  The function invocation details such as function name and argument values are encoded in the data field of a transaction in a well known format, and much like a regular Ether value transaction, the invocation will consume gas.  \\\\n\\\\nA miner must choose to include the transaction within a block in order for the function invocation to take place, so therefore transaction executions are asynchronous in nature.  After broadcasting the transaction, a unique hash is returned, which can then be used to request a transaction receipt from the Ethereum client (once it has been included within a block).\\\\n\\\\nFor a detailed explanation of Ethereum transactions, see [this guide](https://medium.com/blockchannel/life-cycle-of-an-ethereum-transaction-e5c66bae0f6e).\\\\n\\\\n#### Calls\\\\n\\\\nA call is local to the Ethereum client that your service is connected to, and does not broadcast anything to the wider Ethereum network.  Because of this, a contract call is free to execute; they do not consume any gas. However, call operations are read only, meaning that any state changes that occur within the smart contract function are not persisted and are rolled back after execution.  There is no mining involved, so executions are synchronous.\\\\n\\\\n### Using the Contract Wrapper\\\\n\\\\nAs was true for deploying, invoking a function using a Web3j generated contract wrapper is by far the easiest approach.  The tricky data encoding is encapsulated and handled for you under the covers.  \\\\n\\\\nA java method is generated that corresponds to each function within your smart contract.  Web3j establishes if the function should be invoked via a transaction or call automatically, at wrapper generation, based on the keywords of the function.  For example, a function definition that includes the \`view\` or \`pure\` keywords will be executed via a call, otherwise its assumed that there will be some potential state changes, and a transaction approach is used.\\\\n\\\\n#### Invoking \`notarizeDocument(..)\`\\\\nIn our \`DocumentRegistry\` example smart contract, the \`notarizeDocument(..)\` function stores the document details in the smart contract state and should therefore be triggered via a transaction in an asynchronous manner.  The generated function signature is:\\\\n\\\\n\`\`\` java\\\\npublic RemoteCall<TransactionReceipt> notarizeDocument(String _documentHash)\\\\n\`\`\`\\\\nInterestingly, even though behind the scenes, a transaction is asynchronously broadcast to the network and included within a block, Web3j handles the transaction receipt polling on your behalf, and so the remote call returned by this method is actually synchronous and blocks until the transaction has been mined, subsequently returning the transaction receipt .  If this behaviour is not desired within your application, you will have to either send a transaction manually without the help of the wrapper, or make the remote call on a different thread.\\\\n\\\\nSo calling the \`notarizeDocument\` function is made very simple with the wrapper, and looks like this:\\\\n\\\\n\`\`\` java\\\\nDocumentRegistry documentRegistry = deployDocumentRegistryContract();\\\\nTransactionReceipt receipt = documentRegistry.notarizeDocument(\\\\n        \\\\\\"QmXoypizjW3WknFiJnKLwHCnL72vedxjQkDDP1mXWo6uco\\\\\\").send();\\\\n\\\\nString txHash = receipt.getTransactionHash();\\\\n\`\`\`\\\\n\\\\nA \`TransactionException\` is thrown if the transaction fails.\\\\n\\\\n#### Invoking \`isNotarized(..)\`\\\\nAs this function is marked as a \`view\` function, this indicates that it is read-only and can therefore be called locally.  The generated method signature is:\\\\n\\\\n\`\`\` java\\\\npublic RemoteCall<Boolean> isNotarized(String _documentHash)\\\\n\`\`\`\\\\nThis method is quite similar to the \`notarizeDocument(..)\` method, with one major difference;  the returned \`RemoteCall\` is of \`Boolean\` type and not \`TransactionReceipt\`.  This is because a transaction was not sent, and instead the return value of the smart contract function (\`bool\` in this case, converted to \`Boolean\`) is returned synchronously.\\\\n\\\\n### Manual Transaction Sending\\\\nIf for some reason, using the smart contract wrapper is not desirable, Web3j provides a number of helper classes to simplify the process of broadcasting a function invocation transaction, such as encoding the data field of the transaction, and the signing process.\\\\n\\\\n_Manual Transaction Sending Code_\\\\n\`\`\` java\\\\nFunction function = new Function(\\\\\\"notarizeDocument\\\\\\",\\\\n                Arrays.asList(new Utf8String(\\\\\\"QmXoypizjW3WknFiJnKLwHCnL72vedxjQkDDP1mXWo6uco\\\\\\")), Collections.emptyList());\\\\n\\\\n//Encode function values in transaction data format\\\\nString txData = FunctionEncoder.encode(function);\\\\n\\\\nTransactionManager txManager = new FastRawTransactionManager(web3j, creds);\\\\n\\\\nString txHash = txManager.sendTransaction(DefaultGasProvider.GAS_PRICE, DefaultGasProvider.GAS_LIMIT,\\\\n                documentRegistry.getContractAddress(), txData, BigInteger.ZERO).getTransactionHash();\\\\n\`\`\`\\\\n\\\\n- First a \`Function\` object is created.  This defines the \`notarizeDocument\` function call, and contains the function name, a list of input arguments (Web3j provides java equivalents of all solidity smart contract types), and a list of return types (empty in our case).\\\\n\\\\n- Next, the \`FunctionEncoder\` is used to encode the function call definition into the transaction data field format. The actual encoding is out of scope for this article, but details can be found [here](https://solidity.readthedocs.io/en/develop/abi-spec.html) if interested.\\\\n\\\\n- A \`TransactionManager\` is constructed, which which will be used to build and sign the transaction, and broadcast to the Ethereum network. We use a \`FastRawTransactionManager\` in this case, which supports multiple transactions per block, and takes \`Web3j\` and \`Credentials\` objects as arguments. \\\\n\\\\n- Once we have a transaction manager and encoded data, invoking the \`notarizeDocument\` function is simply a matter of calling the \`sendTransaction\` method of the transaction manager.  Behind the scenes this will construct a transaction object, and signing it with the private key defined in the \`Credentials\` and then broadcast the transaction to the Ethereum network via the connected client.  Whereas it was the job of the \`GasProvider\` to set the gas values in the wrapper case, we much specify them manually with this method.  We have used default values in this example but you can change these values as you wish.  As its possible for a smart contract function to receive Ether during the invocation (a \`payable\` function), the last argument can be used to specify the amount of Ether (in the smallest denomination, \`wei\`) that should be sent from the sender account to the smart contract.  No Ether should be transferred in our case, so the value is set to zero.\\\\n\\\\n#### Obtaining the TransactionReceipt\\\\nYou've probably noticed that the \`sendTransaction\` method in the code above, returns a transaction hash, and not a transaction receipt.  This is because of the asynchronous nature of transaction processing that has been mentioned earlier in this guide.  Luckily, web3j also provides a simple way to poll the network and wait until the transaction has been included within a block by a miner, the \`TransactionReceiptProcessor\`:\\\\n\\\\n\`\`\` java\\\\nTransactionReceiptProcessor receiptProcessor =\\\\n                new PollingTransactionReceiptProcessor(web3j, TransactionManager.DEFAULT_POLLING_FREQUENCY,\\\\n                        TransactionManager.DEFAULT_POLLING_ATTEMPTS_PER_TX_HASH);\\\\n\\\\nTransactionReceipt txReceipt = receiptProcessor.waitForTransactionReceipt(txHash);\\\\n\`\`\`\\\\n## Summary\\\\nIn this guide you have learnt how to perform some of the most common interactions with the Ethereum blockchain in java, namely deploying a smart contract and then invoking functions on this contract via both transactions and calls.  Using the generated smart contract java wrappers are by far the easiest way to perform these tasks, but there are other options if you require more granularity.  Congratulations, you're well on your way to becoming a proficient Ethereum java developer!\\\\n\\\\nIn the next article in this series, we will walk you through how to [listen for emitted smart contract events](https://kauri.io/article/760f495423db42f988d17b8c145b0874/listening-for-ethereum-smart-contract-events-in-java).\\\\n\\\\n\\\\n-------------------------------------------\\\\n\\\\n**Next Steps:**\\\\n- [Listening for Ethereum Smart Contract Events in Java](https://kauri.io/article/760f495423db42f988d17b8c145b0874)\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\\\n\\\\n\\\\n\\\\n\\"}",
          "contentHash": "QmR4YmtcjJaKEmLJuwJ8CgJ8BaHFE2LvmQW5Dr979ZTUsG",
          "contributors": Array [
            Object {
              "__typename": "PublicUserDTO",
              "avatar": "https://api.beta.kauri.io:443/ipfs/QmekAbiDvz3Bc5y4pZB7Gnk5Zgn5iaa5CxQoSmTsDoPkP9",
              "id": "4d91838268f6d6d4e590e8fd2a001cd91c32e7a4",
              "name": "Craig Williams",
              "username": "craig",
            },
            Object {
              "__typename": "PublicUserDTO",
              "avatar": "https://api.dev.kauri.io:443/ipfs/QmXa9LzhDV4wiF9YLsv2Z9CBUaSU6ph8QLNRLTDAUBsrA8",
              "id": "f0f15cedc719b5a55470877b0710d5c7816916b1",
              "name": "Grégoire Jeanmart",
              "username": "gregjeanmart",
            },
          ],
          "dateCreated": "2019-07-19T17:17:59.619Z",
          "datePublished": "2019-07-19T17:18:04.060Z",
          "description": "Other articles in this series: - Connecting to an Ethereum client with Java, Eclipse and Web3j - Manage an Ethereum account with Java and Web3j - Generate a Java Wrapper from your Smart Contract - Listening for Ethereum Smart Contract Events in Java - Using Pantheon, the Java Ethereum Client with Linux In this tutorial, you will learn how to deploy a smart contract using the Web3j java library, along with how to interact with the functions of the smart contract. As a prerequisite, you should be",
          "id": "14dc434d11ef4ee18bf7d57f079e246e",
          "owner": Object {
            "__typename": "CommunityDTO",
            "avatar": "https://api.kauri.io:443/ipfs/QmQ9to7bfbR6ADTG2tAKVxWTNw8o3YbwJ1LzdpEJeanLBX",
            "id": "5d2f30daaba2920001c82409",
            "name": "Java Ethereum",
            "resourceIdentifier": Object {
              "__typename": "ResourceIdentifier",
              "id": "5d2f30daaba2920001c82409",
              "type": "COMMUNITY",
            },
          },
          "resourceIdentifier": Object {
            "__typename": "ResourceIdentifier",
            "id": "14dc434d11ef4ee18bf7d57f079e246e",
            "type": "ARTICLE",
            "version": 6,
          },
          "status": "PUBLISHED",
          "tags": Array [
            "ethereum",
            "java",
            "web3j",
            "smart-contracts",
          ],
          "title": "Interacting with an Ethereum Smart Contract in Java",
          "updateComment": null,
          "version": 6,
          "voteResult": Object {
            "__typename": "VoteResultDTO",
            "count": 0,
            "hasVoted": null,
            "quantity": Object {},
            "sum": 0,
          },
        },
        Object {
          "__typename": "ArticleDTO",
          "associatedNfts": null,
          "attributes": Object {
            "background": "https://api.kauri.io:443/ipfs/QmeG7oWJ5J8ZHE2p22Ww3buyAxBgWfkNBTx8Xx761n7gsG",
          },
          "author": Object {
            "__typename": "PublicUserDTO",
            "avatar": "https://api.beta.kauri.io:443/ipfs/QmekAbiDvz3Bc5y4pZB7Gnk5Zgn5iaa5CxQoSmTsDoPkP9",
            "id": "4d91838268f6d6d4e590e8fd2a001cd91c32e7a4",
            "name": "Craig Williams",
            "username": "craig",
          },
          "authorId": "4d91838268f6d6d4e590e8fd2a001cd91c32e7a4",
          "checkpoint": null,
          "comments": Object {
            "__typename": "ResponsePage_CommentDTO",
            "content": Array [],
            "totalElements": 0,
            "totalPages": 0,
          },
          "content": "{\\"markdown\\":\\"\\\\n**Other articles in this series:**\\\\n- [Connecting to an Ethereum client with Java, Eclipse and Web3j](https://kauri.io/article/b9eb647c47a546bc95693acc0be72546)\\\\n- [Manage an Ethereum account with Java and Web3j](https://kauri.io/article/925d923e12c543da9a0a3e617be963b4)\\\\n- [Generate a Java Wrapper from your Smart Contract](https://kauri.io/article/84475132317d4d6a84a2c42eb9348e4b)\\\\n- [Interacting with an Ethereum Smart Contract in Java](https://kauri.io/article/14dc434d11ef4ee18bf7d57f079e246e)\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\\\n\\\\n-------------------------------------------\\\\n\\\\n\\\\n## What is a Smart Contract Event\\\\n\\\\nYou can emit an event from any smart contract function triggered by a transaction, and they are an important piece of the Ethereum application architecture puzzle.\\\\n\\\\nThese events consist of a name and up to 17 arguments, with the content of these arguments provided by the emitting function.  Arguments can either be indexed or non-indexed; with indexed arguments allowing for efficient off-chain querying.\\\\n\\\\n> For example, if event X contains an indexed string argument Y, off-chain I can retrieve all events where Y == \\\\\\"foo\\\\\\", using a filter. (More on filters later)\\\\n\\\\nEvents are stored as logs rather than within EVM storage, and because of this, they have properties that you should be aware of:\\\\n\\\\n-   **Not accessible from within a smart contract:** Although smart contract functions emit events, smart contracts cannot access this event information after emission.  This is true for both the emitting contract and any other external contract. Therefore, you cannot use events for cross-contract communication.\\\\n\\\\n-   **Events are cheap!:** As events are stored as logs, they are cheap compared to the traditional approach of updating the EVM storage state.  The exact cost depends on the event specification and the size of the data within the event.\\\\n\\\\n## Common Uses for Events\\\\n\\\\n### Asynchronous Off-chain Triggers\\\\n\\\\nMost enterprise Java developers are familiar with the Event Bus pattern, where events are published to a queue such as RabbitMQ or Amazon SQS.  This pattern allows services that are interested in specific events to consume them off the bus asynchronously, and perform further processing, without any coupling between the publisher and consumer services.\\\\n\\\\n_The Event Bus Pattern_\\\\n![](https://api.dev.kauri.io:443/ipfs/QmUwbWrK2kgPz2RpwghveWcgRQsH1BSiQhHtam6hFpxp1J)\\\\n\\\\nServices can use Ethereum smart contract events in a similar way, with the Ethereum network acting as a kind of messaging queue.  Off-chain services can register an event filter with a node, and will subsequently be notified each time this event is emitted in the Ethereum network.  You can then use these event notifications as a trigger for further off-chain processing, such as updating a NoSQL based cache of the smart contract state.\\\\n\\\\n_Ethereum as an 'Event Bus'_\\\\n![](https://api.dev.kauri.io:443/ipfs/QmaMerpsdaU6xMT7QfJpfCa8ttZa9DuiGDrQaA7GzRiY9d)\\\\n\\\\n### Cheap Data Storage for Off-chain Consumption\\\\n\\\\nAs I mentioned above, storing data within an event rather than in EVM contract storage is significantly cheaper.\\\\n\\\\n> Diving a little bit into the specifics in order to compare, saving 32 bytes of data to contract storage costs 20,000 gas, whereas emitting an event costs 375 plus 375 for each indexed argument, and an additional 8 gas per byte of data.\\\\n\\\\nDue to these cost savings, it's a common pattern to store data never read by an on-chain smart contract function soley in an event, not in contract storage.\\\\n\\\\nAn example of a scenario where this may be the case, is a notary service where an IPFS hash is committed to the Ethereum blockchain in order to prove date of creation.  After an event has been emitted which contains the IPFS hash of the document, you can verify the timestamp of the notarisation off-chain if there is a dispute by querying the contract events, not the contract state.\\\\n\\\\n## Defining and Emitting an Event\\\\n\\\\nBoth defining and emitting and event within your Ethereum smart contracts are one liners:\\\\n\\\\n### Defining\\\\n\\\\n\`\`\`solidity\\\\nevent Notarized(address indexed notary, string documentHash)\\\\n\`\`\`\\\\n\\\\nIn this example we defined an event with the name \`Notarized\`, with an indexed address argument, \`notary\`,  and a single non-indexed string parameter, \`documentHash\`.\\\\n\\\\n### Emitting\\\\n\\\\n\`\`\`solidity\\\\nfunction notarizeDocument(string _documentHash) public {\\\\n        emit Notarized(msg.sender, _documentHash);\\\\n}\\\\n\`\`\`\\\\n\\\\nThe emit keyword fires an event, with arguments passed to the event in a way that is similar to function invocation.  Here, the notary address is set as the transaction sender address via \`msg.sender\`, and the \`documentHash\` is the same as the called function argument.\\\\n\\\\n## Listening for Emitted Events with Web3j\\\\n\\\\nBy far the easiest way to listen for Ethereum smart contract events using web3j is to use the contract wrapper feature of the library.  For a primer on the wrapper feature, see the previous post in this series [http://todo.com](here).\\\\n\\\\nThe below code snippet connects to a local Ethereum node and listens for all Notarized events emitted from a deployed Notary contract:\\\\n\\\\n\`\`\`java\\\\nWeb3j web3j = Web3j.build(new HttpService(\\\\\\"http://localhost:8545\\\\\\"));\\\\n\\\\n//Deploys a notary contract via wrapper\\\\nfinal Notary notaryContract = deployNotaryContract(web3j);\\\\n\\\\nnotaryContract\\\\n        .notarizedEventFlowable(DefaultBlockParameterName.EARLIEST, DefaultBlockParameterName.LATEST)\\\\n        .subscribe(event -> {\\\\n            final String notary = event.notary;\\\\n            final String documentHash = event.documentHash;\\\\n\\\\n            //Perform processing based on event values\\\\n        });\\\\n\`\`\`\\\\n\\\\nThe autogenerated contract wrapper code contains convenience methods for each event defined in your smart contract with the naming pattern \`<event-name>EventFlowable\`.  This method takes start and end block arguments, and as in this example, using the \`DefaultBlockParameterName.LATEST\` value instructs web3j to continue listening for events for new blocks indefinitely.  If you require a specific block range, you can use \`DefaultBlockParameter.valueOf(BigInteger.valueOf(...))\`.  A [Flowable](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html) object is returned which can then be subscribed to, in order to perform processing logic on emitted events.\\\\n\\\\nThis method simplifies the process of event listening, as it automatically converts the raw log messages into an object with fields reflecting the defined event arguments.  Without this, you would have to decode the values yourself, and although web3j provides helper methods for this, things can get complex quickly.\\\\n\\\\n### Filtering by Indexed Argument Value\\\\n\\\\nSetting an argument of an event as \`indexed\` faciliates efficient querying of events by that arguments value.  This querying is supported in Web3j by building an \`EthFilter\` object manually.  Below is the code to listen for events notarized by a specific Ethereum address:\\\\n\\\\n\`\`\`java\\\\nfinal EthFilter ethFilter = new EthFilter(DefaultBlockParameterName.EARLIEST, DefaultBlockParameterName.LATEST,\\\\n                notaryContract.getContractAddress());\\\\n\\\\nethFilter.addSingleTopic(EventEncoder.encode(notaryContract.NOTARIZED_EVENT));\\\\nethFilter.addOptionalTopics(\\\\\\"0x\\\\\\" + TypeEncoder.encode(new Address(\\\\\\"0x00a329c0648769a73afac7f9381e08fb43dbea72\\\\\\")));\\\\n\\\\nnotaryContract\\\\n        .notarizedEventFlowable(ethFilter)\\\\n        .subscribe(event -> {\\\\n            final String notary = event.notary;\\\\n            final String documentHash = event.documentHash;\\\\n\\\\n            //Perform processing based on event values\\\\n        });\\\\n\`\`\`\\\\n\\\\nThe \`notarizedEventFlowable\` is overloaded, and can accept an \`EthFilter\` as an argument, rather than a block range.  This filter is used to define which events to listen for in a more finely grained way, and is built up with the same block range as was previously passed to the method.\\\\n\\\\nThere are also some topics that are set on the filter.  In an Ethereum filter, the first topic is always defined as the keccak hash of the event signature, with the event signature in our case being \`'Notarised(address,string)''\`.  This is calculated with the help of the \`EventEncoder.encode(..)\` method provided by Web3j, along with the event specification, \`NOTARIZED_EVENT\` that has been auto-generated in the wrapper class.\\\\n\\\\nAdditional topics can be added using the \`addOptionalTopics(..)\` method, and these specify the values of indexed arguments to match against, in the same order as they are defined in the event specification.  Encoding varies slightly based on the type of the argument, but luckily, Web3j provides the \`TypeEncoder\` class which handles this for us.  In the example provided, we are only listening for events where the \`notary\` value is the address 0x00a329c0648769a73afac7f9381e08fb43dbea72.\\\\n\\\\n## Summary\\\\nEvents are a great way for backend (and frontend) services to be notified of smart contract changes and interactions in an asynchronous manner, as well a providing a cost effective way of storing data on the Ethereum blockchain that does not need to be consumed by a smart contract.\\\\n\\\\nAs with many Ethereum interactions, the smart contract wrappers generated by Web3j are by far the simplest way to subscribe to, and process emitted events in your java backend.\\\\n\\\\n\\\\n-------------------------------------------\\\\n\\\\n**Next Steps:**\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\\\n\\"}",
          "contentHash": "QmdxeVg9eaWcJfdLrpuSmVpGZTL8Dw9t3Xh1iSZ7Mpe5N6",
          "contributors": Array [
            Object {
              "__typename": "PublicUserDTO",
              "avatar": "https://api.beta.kauri.io:443/ipfs/QmekAbiDvz3Bc5y4pZB7Gnk5Zgn5iaa5CxQoSmTsDoPkP9",
              "id": "4d91838268f6d6d4e590e8fd2a001cd91c32e7a4",
              "name": "Craig Williams",
              "username": "craig",
            },
            Object {
              "__typename": "PublicUserDTO",
              "avatar": "https://api.dev.kauri.io:443/ipfs/QmXa9LzhDV4wiF9YLsv2Z9CBUaSU6ph8QLNRLTDAUBsrA8",
              "id": "f0f15cedc719b5a55470877b0710d5c7816916b1",
              "name": "Grégoire Jeanmart",
              "username": "gregjeanmart",
            },
          ],
          "dateCreated": "2019-07-22T09:10:19.848Z",
          "datePublished": "2019-07-22T09:10:23.268Z",
          "description": "Other articles in this series: - Connecting to an Ethereum client with Java, Eclipse and Web3j - Manage an Ethereum account with Java and Web3j - Generate a Java Wrapper from your Smart Contract - Interacting with an Ethereum Smart Contract in Java - Using Pantheon, the Java Ethereum Client with Linux What is a Smart Contract Event You can emit an event from any smart contract function triggered by a transaction, and they are an important piece of the Ethereum application architecture puzzle. Th",
          "id": "760f495423db42f988d17b8c145b0874",
          "owner": Object {
            "__typename": "CommunityDTO",
            "avatar": "https://api.kauri.io:443/ipfs/QmQ9to7bfbR6ADTG2tAKVxWTNw8o3YbwJ1LzdpEJeanLBX",
            "id": "5d2f30daaba2920001c82409",
            "name": "Java Ethereum",
            "resourceIdentifier": Object {
              "__typename": "ResourceIdentifier",
              "id": "5d2f30daaba2920001c82409",
              "type": "COMMUNITY",
            },
          },
          "resourceIdentifier": Object {
            "__typename": "ResourceIdentifier",
            "id": "760f495423db42f988d17b8c145b0874",
            "type": "ARTICLE",
            "version": 4,
          },
          "status": "PUBLISHED",
          "tags": Array [
            "ethereum",
            "java",
            "web3j",
            "smart-contracts",
            "events",
          ],
          "title": "Listening for Ethereum Smart Contract Events in Java",
          "updateComment": null,
          "version": 4,
          "voteResult": Object {
            "__typename": "VoteResultDTO",
            "count": 0,
            "hasVoted": null,
            "quantity": Object {},
            "sum": 0,
          },
        },
        Object {
          "__typename": "ArticleDTO",
          "associatedNfts": null,
          "attributes": Object {
            "background": "https://api.kauri.io:443/ipfs/QmUzvLvjLLisUjUunfW81gqCuZ32Uhn5mdiidJ7ArKkkb4",
          },
          "author": Object {
            "__typename": "PublicUserDTO",
            "avatar": "https://api.kauri.io:443/ipfs/QmUR61QiSMk1XqBaAyvA7WmgVBP44x7RQMBa8RU3DCMp6f",
            "id": "824e8fa64ff92b859cc9991ac044e00b665b9b04",
            "name": "Felipe Faraggi",
            "username": "felipefaraggi",
          },
          "authorId": "824e8fa64ff92b859cc9991ac044e00b665b9b04",
          "checkpoint": null,
          "comments": Object {
            "__typename": "ResponsePage_CommentDTO",
            "content": Array [],
            "totalElements": 0,
            "totalPages": 0,
          },
          "content": "{\\"markdown\\":\\"![Toolbelt: Pantheon included!](https://i.imgur.com/LhdU0DH.jpg)\\\\nOriginal photo by [Jesse Orrico](https://unsplash.com/@jessedo81?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)\\\\n\\\\nThis is the first article of a 3-part series on installing Pantheon, the Java client for Ethereum:\\\\n\\\\n1.  [Linux](#)\\\\n2.  macOS\\\\n3.  Windows\\\\n\\\\nHaving some powerful tools in your toolbelt is essential for a Java developer, and one of the crucial tools for an Ethereum blockchain developer is the network client. This is the piece of software that communicates data to and from the blockchain. Among other things, the client: spins up nodes, acts as a peer discovery agent to see who else is participating in the network and validates and sends transactions.\\\\n\\\\nThis guide helps you install and setup this core part you need for programming on Ethereum with Java. Although there are some great networking clients out there, Pantheon is the only one written in Java.\\\\n\\\\nPantheon is an open-source, Apache 2.0 licensed Ethereum client written in Java. It is mainnet compatible, has a modular architecture, and has privacy and permissioning features as well as new consensus algorithms.\\\\n\\\\nThis is the first of a series of step-by-step guides to install and configure the Pantheon client on Linux/macOS/Windows. This guide focuses on Linux operating system, but you can use many of the commands and steps on macOS with some basic modifications.\\\\n\\\\n## Try Pantheon with Docker\\\\n\\\\nBefore installing, I would suggest anyone wanting to setup and install Pantheon for the first time to try it out using our [Docker images](http://docs.pantheon.pegasys.tech/en/stable/Getting-Started/Run-Docker-Image/). The requirements to do so are having [Docker installed](https://docs.docker.com/v17.12/install/linux/docker-ce/ubuntu/) and using Linux or macOS.\\\\nYou can use a single docker command to run a mainnet, local or rinkeby version of Pantheon, and then use [\`curl\`](https://curl.haxx.se/) or similar tools to get or post data to the running node.\\\\n\\\\n> For quick, temporary tests this guide uses \`/tmp/pantheon/dev/\`, \`/tmp/pantheon/mainnet/\`, \`/tmp/pantheon/rinkeby/\` as mount volumes, which are automatically cleaned at every boot. You can create other folders instead, but whichever option you choose, make sure you create the folders first.\\\\n\\\\n\`\`\`shell\\\\n$ mkdir -p /tmp/pantheon/dev/\\\\n$ mkdir -p /tmp/pantheon/mainnet/\\\\n$ mkdir -p /tmp/pantheon/rinkeby/\\\\n\`\`\`\\\\n\\\\nHere are some examples:\\\\n\\\\nMainnet Node:\\\\n\\\\n\`\`\`shell\\\\ndocker run pegasyseng/pantheon:latest\\\\n\`\`\`\\\\n\\\\nLocal test Node with Websockets and HTTP RPC services enabled:\\\\n\\\\n\`\`\`shell\\\\ndocker run -p 8545:8545 -p 8546:8546 --mount type=bind,source=/tmp/pantheon/dev,target=/var/lib/pantheon pegasyseng/pantheon:latest --miner-enabled --miner-coinbase fe3b557e8fb62b89f4916b721be55ceb828dbd73 --rpc-http-cors-origins=\\\\\\"all\\\\\\" --rpc-ws-enabled --network=dev\\\\n\`\`\`\\\\n\\\\nRinkeby Node:\\\\n\\\\n\`\`\`shell\\\\ndocker run -p 30303:30303 --mount type=bind,source=/tmp/pantheon/rinkeby,target=/var/lib/pantheon pegasyseng/pantheon:latest --network=rinkeby\\\\n\`\`\`\\\\n\\\\nWhile the node is running, you can use another terminal window to interact with the node.\\\\n\\\\n![](https://i.imgur.com/kw1VHDs.png)\\\\n\\\\nFor example, using \`curl\` to call the \`eth_chainId\` RPC method:\\\\n\\\\n\`\`\`shell\\\\ncurl -X POST --data '{\\\\\\"jsonrpc\\\\\\":\\\\\\"2.0\\\\\\",\\\\\\"method\\\\\\":\\\\\\"eth_chainId\\\\\\",\\\\\\"params\\\\\\":[],\\\\\\"id\\\\\\":1}' localhost:8545\\\\n\`\`\`\\\\n\\\\n* * *\\\\n\\\\n## Getting started with Linux\\\\n\\\\nTwo installation methods are available:\\\\n\\\\n-   [Installing the binary distribution](http://docs.pantheon.pegasys.tech/en/stable/Installation/Install-Binaries/)\\\\n    For binary installation, [follow along to this section](#binary-install) and skip the next.\\\\n-   [Building from source](http://docs.pantheon.pegasys.tech/en/stable/Installation/Build-From-Source/)\\\\n    For building from source, [skip to this section](#build-from-source).\\\\n\\\\n> **Requirements**: For both of these methods, Pantheon needs the Java JDK installed on your machine. Current versions of Pantheon require Java JDK 11+ installed.\\\\n\\\\n### Binary install\\\\n\\\\nRemember to have at least 4GB of RAM if running a private network, and [review  the further requirements](http://docs.pantheon.pegasys.tech/en/stable/Installation/Overview/#disk-space-and-ram-requirements) for other installation types.\\\\n\\\\n1.  [Download the Pantheon binaries](https://bintray.com/consensys/pegasys-repo/pantheon/_latestVersion#files).\\\\n\\\\nYou can use \`wget\` to do this.\\\\n\\\\n\`\`\`shell\\\\n$ sudo apt install wget\\\\n$ cd ~/bin/\\\\n$ wget   https://bintray.com/consensys/pegasys-repo/download_file?file_path=pantheon-1.1.4.tar.gz -O pantheon-1.1.4.tar.gz\\\\n$ wget https://bintray.com/consensys/pegasys-repo/download_file\\\\\\\\?file_path\\\\\\\\=pantheon-1.1.4.tar.gz -O pantheon-1.1.4.tar.gz\\\\n\`\`\`\\\\n\\\\n> \`$HOME/bin/\` and \`$HOME/.local/{bin,opt,usr}\` are the recommended install folders for local user binaries on machines used by a single user. Other options are available such as \`/opt/local/\` or \`/usr/local/bin/\` depending on your local setup and preference. [Read this Stack Exchange thread for more details](https://unix.stackexchange.com/questions/36871/where-should-a-local-executable-be-placed).\\\\n\\\\n2.  Unpack the compressed file:\\\\n\\\\n\`\`\`shell\\\\n$ tar -xzf pantheon-1.1.4.tar.gz\\\\n$ cd pantheon-1.1.4\\\\n\`\`\`\\\\n\\\\n> Replace 1.1.4 with whichever release you downloaded.\\\\n\\\\n3.  Confirm the download isn't corrupted and check the version .The output should return the Pantheon and JDK version.\\\\n\\\\n\`\`\`shell\\\\n$ bin/pantheon --version\\\\npantheon/v1.1.4/linux-x86_64/oracle_openjdk-java-11\\\\n\`\`\`\\\\n\\\\n### Build from Source\\\\n\\\\nTwo options are available: [installing and running locally](http://docs.pantheon.pegasys.tech/en/stable/Installation/Build-From-Source/#installation-on-linux-unix-mac-os-x) or [on a VM](http://docs.pantheon.pegasys.tech/en/stable/Installation/Build-From-Source/#installation-on-vm).\\\\n\\\\nThis guide focuses on the local solution.\\\\n\\\\n1.  Clone the Pantheon codebase\\\\n\\\\n\`\`\`shell\\\\n$ cd ~/bin/\\\\n$ git clone --recursive https://github.com/PegaSysEng/pantheon.git\\\\n\`\`\`\\\\n\\\\n2.  Build Pantheon\\\\n\\\\n\`\`\`shell\\\\n$ cd pantheon/\\\\n$ ./gradlew build -x test\\\\n\`\`\`\\\\n\\\\n3.  Choose distribution version and check version.\\\\n\\\\n\`\`\`shell\\\\n$ cd build/distributions/\\\\n$ tar -xzf pantheon-1.1.4.tar.gz\\\\n$ cd pantheon-1.1.4/\\\\n$ bin/pantheon --version\\\\n$ bin/pantheon --help\\\\n\`\`\`\\\\n\\\\n## Config\\\\n\\\\nNo additional configuration is necessary for Pantheon to run correctly.\\\\nEach different network type (including mainnet) set by the \`--network\` command line flags automatically loads the appropriate default configuration.\\\\n\\\\nIf you need to change the settings, these options are either configured at Node or Network-level.\\\\nNetwork-level settings are defined in the genesis file and are loaded by every Node connected to that specific network. Whereas Node-level settings are modified either in the node configuration file, or through command line flags.\\\\n\\\\nFor more information on configuration, [read the corresponding documentation](http://docs.pantheon.pegasys.tech/en/stable/Configuring-Pantheon/Network-vs-Node/).\\\\n\\\\n## Starting Pantheon\\\\n\\\\nAfter you have completed the above steps, you can continue using this distribution with the [regular Starting Pantheon guide](http://docs.pantheon.pegasys.tech/en/stable/Getting-Started/Starting-Pantheon/).\\\\n\\\\nFor a quick preview, this could be an HTTP request on a \`dev\` network Node running with docker.\\\\n\\\\n\`\`\`shell\\\\n$ docker run -p 8545:8545 --mount type=bind,source=/tmp/pantheon/dev,target=/var/lib/pantheon pegasyseng/pantheon:latest --miner-enabled --miner-coinbase fe3b557e8fb62b89f4916b721be55ceb828dbd73 --rpc-http-cors-origins=\\\\\\"all\\\\\\" --rpc-http-enabled --network=dev\\\\n\`\`\`\\\\n\\\\nThis is how you build a request calling the \`eth_chainId\` method.\\\\n\\\\n\`\`\`java\\\\nString payload='{\\\\\\"jsonrpc\\\\\\":\\\\\\"2.0\\\\\\",\\\\\\"method\\\\\\":\\\\\\"eth_chainId\\\\\\",\\\\\\"params\\\\\\":[],\\\\\\"id\\\\\\":1}';\\\\nString requestUrl=\\\\\\"http://localhost:8545\\\\\\";\\\\nsendRequest(requestUrl, payload);\\\\n\`\`\`\\\\n\\\\nAnd the method implementation:\\\\n\\\\n\`\`\`java\\\\npublic static String sendRequest(String requestUrl, String payload) {\\\\n    try {\\\\n        URL url = new URL(requestUrl);\\\\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\\\\n\\\\n        connection.setDoInput(true);\\\\n        connection.setDoOutput(true);\\\\n        connection.setRequestMethod(\\\\\\"GET\\\\\\");\\\\n        connection.setRequestProperty(\\\\\\"Accept\\\\\\", \\\\\\"application/json\\\\\\");\\\\n        connection.setRequestProperty(\\\\\\"Content-Type\\\\\\", \\\\\\"application/json; charset=UTF-8\\\\\\");\\\\n        OutputStreamWriter outputWriter = new OutputStreamWriter(connection.getOutputStream(), \\\\\\"UTF-8\\\\\\");\\\\n\\\\n        outputWriter.write(payload);\\\\n        outputWriter.close();\\\\n\\\\n        BufferedReader buffer = new BufferedReader(new InputStreamReader(connection.getInputStream()));\\\\n        StringBuffer jsonString = new StringBuffer();\\\\n        String line;\\\\n        while ((line = buffer.readLine()) != null) {\\\\n                jsonString.append(line);\\\\n        }\\\\n        buffer.close();\\\\n\\\\n        connection.disconnect();\\\\n        return jsonString.toString();\\\\n    } catch (Exception e) {\\\\n            throw new RuntimeException(e.getMessage());\\\\n    }\\\\n}\\\\n\`\`\`\\\\n\\\\nThat request should return the following result:\\\\n\\\\n\`\`\`json\\\\n{\\\\n  \\\\\\"jsonrpc\\\\\\" : \\\\\\"2.0\\\\\\",\\\\n  \\\\\\"id\\\\\\" : 1,\\\\n  \\\\\\"result\\\\\\" : {\\\\n    \\\\\\"startingBlock\\\\\\" : \\\\\\"0x0\\\\\\",\\\\n    \\\\\\"currentBlock\\\\\\" : \\\\\\"0x2d0\\\\\\",\\\\n    \\\\\\"highestBlock\\\\\\" : \\\\\\"0x66c0\\\\\\"\\\\n  }\\\\n}\\\\n\`\`\`\\\\n\\\\nFine more information in the [Pantheon documentation](http://docs.pantheon.pegasys.tech/en/stable/).\\"}",
          "contentHash": "QmdG4nTrWQomqGSxRa3JNA7hQN1W7Jy1yPaKkgnaNFJR3n",
          "contributors": Array [
            Object {
              "__typename": "PublicUserDTO",
              "avatar": "https://api.kauri.io:443/ipfs/QmUR61QiSMk1XqBaAyvA7WmgVBP44x7RQMBa8RU3DCMp6f",
              "id": "824e8fa64ff92b859cc9991ac044e00b665b9b04",
              "name": "Felipe Faraggi",
              "username": "felipefaraggi",
            },
          ],
          "dateCreated": "2019-07-19T12:57:15.901Z",
          "datePublished": "2019-07-19T12:57:18.891Z",
          "description": "Toolbelt: Pantheon included! Original photo by Jesse Orrico This is the first article of a 3-part series on installing Pantheon, the Java client for Ethereum: Linux macOS Windows Having some powerful tools in your toolbelt is essential for a Java developer, and one of the crucial tools for an Ethereum blockchain developer is the network client. This is the piece of software that communicates data to and from the blockchain. Among other things, the client: spins up nodes, acts as a peer discovery",
          "id": "276dd27f1458443295eea58403fd6965",
          "owner": Object {
            "__typename": "CommunityDTO",
            "avatar": "https://api.kauri.io:443/ipfs/QmQ9to7bfbR6ADTG2tAKVxWTNw8o3YbwJ1LzdpEJeanLBX",
            "id": "5d2f30daaba2920001c82409",
            "name": "Java Ethereum",
            "resourceIdentifier": Object {
              "__typename": "ResourceIdentifier",
              "id": "5d2f30daaba2920001c82409",
              "type": "COMMUNITY",
            },
          },
          "resourceIdentifier": Object {
            "__typename": "ResourceIdentifier",
            "id": "276dd27f1458443295eea58403fd6965",
            "type": "ARTICLE",
            "version": 2,
          },
          "status": "PUBLISHED",
          "tags": Array [
            "ethereum",
            "pegasys",
            "java",
            "installation",
            "client",
            "pantheon",
          ],
          "title": "Using Pantheon, the Java Ethereum Client with Linux",
          "updateComment": null,
          "version": 2,
          "voteResult": Object {
            "__typename": "VoteResultDTO",
            "count": 0,
            "hasVoted": null,
            "quantity": Object {},
            "sum": 0,
          },
        },
      ]
    }
    approvedId={
      Array [
        Object {
          "__typename": "ResourceIdentifier",
          "id": "b9eb647c47a546bc95693acc0be72546",
          "type": "ARTICLE",
        },
        Object {
          "__typename": "ResourceIdentifier",
          "id": "925d923e12c543da9a0a3e617be963b4",
          "type": "ARTICLE",
        },
        Object {
          "__typename": "ResourceIdentifier",
          "id": "84475132317d4d6a84a2c42eb9348e4b",
          "type": "ARTICLE",
        },
        Object {
          "__typename": "ResourceIdentifier",
          "id": "14dc434d11ef4ee18bf7d57f079e246e",
          "type": "ARTICLE",
        },
        Object {
          "__typename": "ResourceIdentifier",
          "id": "760f495423db42f988d17b8c145b0874",
          "type": "ARTICLE",
        },
        Object {
          "__typename": "ResourceIdentifier",
          "id": "276dd27f1458443295eea58403fd6965",
          "type": "ARTICLE",
        },
      ]
    }
    attributes={
      Object {
        "background": "https://api.kauri.io:443/ipfs/QmPyoXQaK9uA1oedsptssr1EhYRBF1A9vrnypbKAkMhuxQ",
      }
    }
    avatar="https://api.kauri.io:443/ipfs/QmQ9to7bfbR6ADTG2tAKVxWTNw8o3YbwJ1LzdpEJeanLBX"
    creator={
      Object {
        "__typename": "PublicUserDTO",
        "id": "f0f15cedc719b5a55470877b0710d5c7816916b1",
        "name": "Grégoire Jeanmart",
        "username": "gregjeanmart",
      }
    }
    creatorId="f0f15cedc719b5a55470877b0710d5c7816916b1"
    dateCreated="2019-07-17T14:29:46.550Z"
    dateUpdated="2019-07-23T15:27:47.396Z"
    description="Java is one of the worlds most popular programming languages used in global-scale applications by developers everywhere. This community brings together developers and projects at the forefront of bringing Ethereum support to this rich language ecosystem."
    homepage={
      Array [
        Object {
          "__typename": "SectionDTO",
          "description": "Take your first steps integrating Java with Ethereum",
          "name": "Getting Started",
          "resources": Array [
            Object {
              "__typename": "ArticleDTO",
              "attributes": Object {
                "background": "https://api.kauri.io:443/ipfs/QmZjb5Kp3LFcXTVxneoJN3aco6NF91M7TbVfxUq4B4ySsX",
              },
              "author": Object {
                "__typename": "PublicUserDTO",
                "avatar": "https://api.dev.kauri.io:443/ipfs/QmXa9LzhDV4wiF9YLsv2Z9CBUaSU6ph8QLNRLTDAUBsrA8",
                "id": "f0f15cedc719b5a55470877b0710d5c7816916b1",
                "name": "Grégoire Jeanmart",
                "username": "gregjeanmart",
              },
              "content": "{\\"markdown\\":\\"\\\\n**Other articles in this series:**\\\\n- [Manage an Ethereum account with Java and Web3j](https://kauri.io/article/925d923e12c543da9a0a3e617be963b4)\\\\n- [Generate a Java Wrapper from your Smart Contract](https://kauri.io/article/84475132317d4d6a84a2c42eb9348e4b)\\\\n- [Interacting with an Ethereum Smart Contract in Java](https://kauri.io/article/14dc434d11ef4ee18bf7d57f079e246e)\\\\n- [Listening for Ethereum Smart Contract Events in Java](https://kauri.io/article/760f495423db42f988d17b8c145b0874)\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\\\n\\\\n---------------------------------------------------\\\\n\\\\n[**Ethereum**](https://www.ethereum.org/) is a Blockchain, which means it operates on a [peer-to-peer network](https://en.wikipedia.org/wiki/Peer-to-peer) composed of thousand of nodes where each node agrees on the next state.\\\\n\\\\nIn order to interact with the Ethereum global state (distributed database), a program needs to connect to a node that exposes the standard [JSON-RPC API](https://github.com/ethereum/wiki/wiki/JSON-RPC#json-rpc-api) which can be used to execute operations on the Ethereum blockchain.\\\\n\\\\nIn this article, we will learn how to start an Ethereum Java project and connect to a node using the Java library **[Web3j](https://web3j.io/)**, a lightweight and modular library implementing all the functionallities required to work with Ethereum (JSON-RPC API client, wallet account management, Java Smart Contract wrapper, support for ENS, ERC20 and ERC721 and much more).\\\\n\\\\n![](https://web3j.readthedocs.io/en/latest/_images/web3j_network.png)\\\\n\\\\n## Prerequisite\\\\n\\\\nTo run this tutorial, we must have the following installed:\\\\n\\\\n-   [Java programming language](https://java.com/en/download/) (> 8)\\\\n\\\\n\`\`\`shell\\\\n$ java -version\\\\njava version \\\\\\"1.8.0_201\\\\\\"\\\\n\`\`\`\\\\n\\\\n-   A package and dependancy manager, for example [Maven](https://maven.apache.org/) or [Gradle](https://gradle.org/install/)\\\\n-   An IDE (Integrated development environment), for this tutorial, we use [Eclipse](https://www.eclipse.org/downloads/)\\\\n\\\\n## Start a new project\\\\n\\\\nFirst create a new Maven project called \`java_ethereum\` in Eclipse.\\\\n\\\\n### 1. Create a new Maven project\\\\n\\\\nOnce Eclipse is launched, we need to create a new Maven project. Go to _File > New > Project > Maven > Maven Project_\\\\n\\\\nCheck the box _Create a simple project (skip archetype selection)_ and click on _Next >_.\\\\n\\\\nNext screen, enter the _Group ID_ and _Artifact ID_ of our project then click _Finish_.\\\\n\\\\nGroup Id: \`io.kauri.tutorials.java-ethereum\`\\\\n\\\\nArtifact Id: \`java-ethereum\`\\\\n\\\\n![](https://imgur.com/IpEZ6gX.png)\\\\n\\\\nIt should result of a new project in the _Project Explorer_\\\\n\\\\n![](https://imgur.com/7uiey3U.png)\\\\n\\\\n### 2. Configure our project to use Java 8\\\\n\\\\nFinally, we need to tell Eclipse and Maven to use Java version 8.\\\\n\\\\nEdit the file \`pom.xml\` and add the following lines before \`</project>\`\\\\n\\\\n\`\`\`xml\\\\n  <properties>\\\\n    <maven.compiler.target>1.8</maven.compiler.target>\\\\n    <maven.compiler.source>1.8</maven.compiler.source>\\\\n  </properties>\\\\n\`\`\`\\\\n\\\\nNow, right click on the project name in the _Project Explorer_ and click on _Maven > Update Project_. Click _OK_ in the dialog box that pops up.\\\\n\\\\nIn the _Project Explorer_, You should see the _JRE System library_ changing from **JavaSE-1.5** to **JavaSE-1.8**.\\\\n\\\\n![](https://imgur.com/7Pvq9hJ.png)\\\\n\\\\n## Add Web3j library to our project\\\\n\\\\nIn this step, we import the latest version of Web3j to our project via maven.\\\\n\\\\nIn Eclipse, edit the file \`pom.xml\` and add the following lines before \`</project>\`:\\\\n\\\\n\`\`\`xml\\\\n  <dependencies>\\\\n    <dependency>\\\\n      <groupId>org.web3j</groupId>\\\\n      <artifactId>core</artifactId>\\\\n      <version>4.3.0</version>\\\\n    </dependency>\\\\n  </dependencies>\\\\n\`\`\`\\\\n\\\\n_Full pom.xml file available [here](https://github.com/gjeanmart/kauri-content/blob/master/java-ethereum/pom.xml)_\\\\n\\\\nSave file and dependencies will import. In your package explorer you will see a Maven dependencies folder with all the JAR (Java ARchive) packages for web3j and its dependencies.\\\\n\\\\n## Create a Main class\\\\n\\\\nNow, we have all the required dependencies to use Web3j, we can start coding our Ethereum Java program.\\\\n\\\\nCreate a Java class \`Main.java\` in your project by right-clicking on the project and selecting _New > Class_.\\\\nEnter the package name \`io.kauri.tutorials.java_ethereum\`, the class name \`Main\` and check _public static void main(String\\\\\\\\[] args)_.\\\\n\\\\n![](https://imgur.com/iipSbO0.png)\\\\n\\\\nClick on _Finish_ to generate the skeleton file.\\\\n\\\\n\`\`\`java\\\\n//Main.java\\\\npackage io.kauri.tutorials.java_ethereum;\\\\n\\\\npublic class Main {\\\\n  public static void main(String[] args) {\\\\n    // TODO Auto-generated method stub\\\\n  }\\\\n}\\\\n\`\`\`\\\\n\\\\n## Connect to an Ethereum node with Web3j.\\\\n\\\\nNow we have created our project, imported the Web3j library and prepared a program to run our code. We can now connect to an Ethereum node and start executing operations over the JSON-RPC API abstracted by Web3j.\\\\n\\\\n### 1. Add imports\\\\n\\\\nFirst import the packages needed for our code, or allow your IDE to automatically import them for you:\\\\n\\\\n\`\`\`java\\\\nimport java.io.IOException;\\\\nimport org.web3j.protocol.Web3j;\\\\nimport org.web3j.protocol.http.HttpService;\\\\nimport org.web3j.protocol.core.methods.response.EthBlockNumber;\\\\nimport org.web3j.protocol.core.methods.response.EthGasPrice;\\\\nimport org.web3j.protocol.core.methods.response.Web3ClientVersion;\\\\n\`\`\`\\\\n\\\\n### 2. Connect to the node\\\\n\\\\nTo connect to the node, Web3j requires the JSON-RPC API endpoint:\\\\n\\\\n\`\`\`java\\\\nWeb3j web3 = Web3j.build(new HttpService(\\\\\\"<NODE ENDPOINT>\\\\\\"));\\\\n\`\`\`\\\\n\\\\n#### Local Ethereum node or ganache-cli\\\\n\\\\nIf you are running locally a [Geth](https://geth.ethereum.org/), [Parity](https://www.parity.io/), [Pantheon](https://github.com/PegaSysEng/pantheon) client or [ganache-cli](https://github.com/trufflesuite/ganache-cli). Your node JSON-RPC API endpoint is \`http://localhost:8545\` by default\\\\n\\\\n\`\`\`java\\\\nWeb3j web3 = Web3j.build(new HttpService(\\\\\\"http://localhost:8545\\\\\\"));\\\\n\`\`\`\\\\n\\\\n#### Ganache application: Local development blockchain\\\\n\\\\nIf you are running the [Ganache](https://www.trufflesuite.com/ganache) application on your machine. Your node JSON-RPC API endpoint is \`http://localhost:7545\` by default. _ganche-cli uses port 8545_\\\\n\\\\n\`\`\`java\\\\nWeb3j web3 = Web3j.build(new HttpService(\\\\\\"http://localhost:7545\\\\\\"));\\\\n\`\`\`\\\\n\\\\n_Note: As a test network, Ganache doesn't support all the JSON-RPC API operations specified, for example \`net_peercount\`._\\\\n\\\\n#### Infura: Hosted nodes for public mainet and testnets\\\\n\\\\nIf you use [Infura](https://infura.io). The node JSON-RPC API endpoint is \`https://<network>.infura.io/v3/<project key>\`.\\\\n\\\\n\`\`\`java\\\\nWeb3j web3 = Web3j.build(new HttpService(\\\\\\"https://mainnet.infura.io/v3/<project key>\\\\\\"));\\\\n\`\`\`\\\\n\\\\n### 3. Execute API operations\\\\n\\\\nWeb3j implements a JSON-RPC API client for Ethereum which can be used in the following way \`<response> = web3.<operation>.send()\`. For example:\\\\n\\\\n\`\`\`java\\\\ntry {\\\\n  // web3_clientVersion returns the current client version.\\\\n  Web3ClientVersion clientVersion = web3.web3ClientVersion().send();\\\\n\\\\n  //eth_blockNumber returns the number of most recent block.\\\\n  EthBlockNumber blockNumber = web3.ethBlockNumber().send();\\\\n\\\\n  //eth_gasPrice, returns the current price per gas in wei.\\\\n  EthGasPrice gasPrice =  web3.ethGasPrice().send();\\\\n\\\\n} catch(IOException ex) {\\\\n  throw new RuntimeException(\\\\\\"Error whilst sending json-rpc requests\\\\\\", ex);\\\\n}\\\\n\`\`\`\\\\n\\\\n**Note:** Serilization of the JSON-RPC request can raise an \`IOException\` exception, so you need to handle it.\\\\n\\\\n## Result\\\\n\\\\nThe following code shows the entire Java program which connects to an Ethereum node and runs some JSON-RPC calls.\\\\n\\\\n\`\`\`java\\\\n//Main.java\\\\npackage io.kauri.tutorials.java_ethereum;\\\\n\\\\nimport java.io.IOException;\\\\n\\\\nimport org.web3j.protocol.Web3j;\\\\nimport org.web3j.protocol.core.methods.response.EthBlockNumber;\\\\nimport org.web3j.protocol.core.methods.response.EthGasPrice;\\\\nimport org.web3j.protocol.core.methods.response.Web3ClientVersion;\\\\nimport org.web3j.protocol.http.HttpService;\\\\n\\\\npublic class Main {\\\\n\\\\n  public static void main(String[] args) {\\\\n    System.out.println(\\\\\\"Connecting to Ethereum ...\\\\\\");\\\\n    Web3j web3 = Web3j.build(new HttpService(\\\\\\"http://localhost:8545\\\\\\"));\\\\n    System.out.println(\\\\\\"Successfuly connected to Ethereum\\\\\\");\\\\n\\\\n    try {\\\\n      // web3_clientVersion returns the current client version.\\\\n      Web3ClientVersion clientVersion = web3.web3ClientVersion().send();\\\\n\\\\n      // eth_blockNumber returns the number of most recent block.\\\\n      EthBlockNumber blockNumber = web3.ethBlockNumber().send();\\\\n\\\\n      // eth_gasPrice, returns the current price per gas in wei.\\\\n      EthGasPrice gasPrice = web3.ethGasPrice().send();\\\\n\\\\n      // Print result\\\\n      System.out.println(\\\\\\"Client version: \\\\\\" + clientVersion.getWeb3ClientVersion());\\\\n      System.out.println(\\\\\\"Block number: \\\\\\" + blockNumber.getBlockNumber());\\\\n      System.out.println(\\\\\\"Gas price: \\\\\\" + gasPrice.getGasPrice());\\\\n\\\\n    } catch (IOException ex) {\\\\n      throw new RuntimeException(\\\\\\"Error whilst sending json-rpc requests\\\\\\", ex);\\\\n    }\\\\n  }\\\\n}\\\\n\`\`\`\\\\n\\\\n_Full file available [here](https://github.com/gjeanmart/kauri-content/blob/master/java-ethereum/src/main/java/io/kauri/tutorials/java_ethereum/Main.java)_\\\\n\\\\nTo run the program, right-click on the file \`Main.java\` and click on _Run As > Java Application_. You should see in the console the following result.\\\\n\\\\n\`\`\`shell\\\\nConnecting to Ethereum ...\\\\nSuccessfuly connected to Ethereum\\\\nClient version: Geth/v1.8.22-omnibus-260f7fbd/linux-amd64/go1.11.1\\\\nBlock number: 7983049\\\\nGas price: 3000000000\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/MWJqowg.gif)\\\\n\\\\n## References\\\\n\\\\n-   [GitHub Project code](https://github.com/gjeanmart/kauri-content/tree/master/java-ethereum)\\\\n-   [Web3j website](https://web3j.io/)\\\\n-   [Web3j documentation](https://web3j.readthedocs.io/en/latest/)\\\\n-   [Web3j Github repo](https://github.com/web3j/web3j)\\\\n-   [Ethereum JSON-RPC API](https://github.com/ethereum/wiki/wiki/JSON-RPC)\\\\n\\\\n\\\\n-----------------------------\\\\n\\\\n**Next Steps:**\\\\n\\\\n- [Manage an Ethereum account with Java and Web3j](https://kauri.io/article/925d923e12c543da9a0a3e617be963b4)\\\\n- [Generate a Java Wrapper from your Smart Contract](https://kauri.io/article/84475132317d4d6a84a2c42eb9348e4b)\\\\n- [Interacting with an Ethereum Smart Contract in Java](https://kauri.io/article/14dc434d11ef4ee18bf7d57f079e246e)\\\\n- [Listening for Ethereum Smart Contract Events in Java](https://kauri.io/article/760f495423db42f988d17b8c145b0874)\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\\\n\\"}",
              "contributors": Array [
                Object {
                  "__typename": "PublicUserDTO",
                  "avatar": "https://api.dev.kauri.io:443/ipfs/QmXa9LzhDV4wiF9YLsv2Z9CBUaSU6ph8QLNRLTDAUBsrA8",
                  "id": "f0f15cedc719b5a55470877b0710d5c7816916b1",
                  "name": "Grégoire Jeanmart",
                  "username": "gregjeanmart",
                },
              ],
              "dateCreated": "2019-07-19T15:40:19.256Z",
              "datePublished": "2019-07-19T15:40:22.354Z",
              "description": "Other articles in this series: - Manage an Ethereum account with Java and Web3j - Generate a Java Wrapper from your Smart Contract - Interacting with an Ethereum Smart Contract in Java - Listening for Ethereum Smart Contract Events in Java - Using Pantheon, the Java Ethereum Client with Linux Ethereum is a Blockchain, which means it operates on a peer-to-peer network composed of thousand of nodes where each node agrees on the next state. In order to interact with the Ethereum global state (distr",
              "id": "b9eb647c47a546bc95693acc0be72546",
              "owner": Object {
                "__typename": "CommunityDTO",
                "avatar": "https://api.kauri.io:443/ipfs/QmQ9to7bfbR6ADTG2tAKVxWTNw8o3YbwJ1LzdpEJeanLBX",
                "id": "5d2f30daaba2920001c82409",
                "name": "Java Ethereum",
                "resourceIdentifier": Object {
                  "__typename": "ResourceIdentifier",
                  "id": "5d2f30daaba2920001c82409",
                  "type": "COMMUNITY",
                },
              },
              "resourceIdentifier": Object {
                "__typename": "ResourceIdentifier",
                "id": "b9eb647c47a546bc95693acc0be72546",
                "type": "ARTICLE",
              },
              "status": "PUBLISHED",
              "title": "Connecting to an Ethereum client with Java, Eclipse and Web3j",
              "version": 2,
              "voteResult": Object {
                "__typename": "VoteResultDTO",
                "sum": 0,
              },
            },
            Object {
              "__typename": "ArticleDTO",
              "attributes": Object {
                "background": "https://api.kauri.io:443/ipfs/QmTyEg3Lq2Bf2anauJnHcGtHiAJZ71kAbY2quL7jXZeWkh",
              },
              "author": Object {
                "__typename": "PublicUserDTO",
                "avatar": "https://api.dev.kauri.io:443/ipfs/QmXa9LzhDV4wiF9YLsv2Z9CBUaSU6ph8QLNRLTDAUBsrA8",
                "id": "f0f15cedc719b5a55470877b0710d5c7816916b1",
                "name": "Grégoire Jeanmart",
                "username": "gregjeanmart",
              },
              "content": "{\\"markdown\\":\\"**Other articles in this series:**\\\\n- [Connecting to an Ethereum client with Java, Eclipse and Web3j](https://kauri.io/article/b9eb647c47a546bc95693acc0be72546)\\\\n- [Generate a Java Wrapper from your Smart Contract](https://kauri.io/article/84475132317d4d6a84a2c42eb9348e4b)\\\\n- [Interacting with an Ethereum Smart Contract in Java](https://kauri.io/article/14dc434d11ef4ee18bf7d57f079e246e)\\\\n- [Listening for Ethereum Smart Contract Events in Java](https://kauri.io/article/760f495423db42f988d17b8c145b0874)\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\\\n\\\\n-------------------------------------------\\\\n\\\\nThe Ethereum blockchain is often compared to a World Computer with a global state. The global state grows after each new block and cosists of many accounts organised in a [Merkle tree](https://en.wikipedia.org/wiki/Merkle_tree).\\\\n\\\\n![](https://imgur.com/iQLdaOW.png)\\\\n\\\\nEach account has a state composed of information such as balance, nonce, storageRoot and codeHash, and is identified by a 20 bytes address (for example: \`0x66aac71c0c81ec00aebead84914a10e307a4cbf9\`).\\\\n\\\\nThere are two types of accounts:\\\\n\\\\n-   **Externally owned accounts**, which are controlled by private keys and have no code associated with them.\\\\n-   **Contract accounts**, which are controlled by their contract code and have code associated with them.\\\\n\\\\n![](https://imgur.com/3dlka35.png)\\\\n\\\\nIn this tutorial, we focus on externally owned accounts and how to retrieve information such as a balance, create or open an account and send transactions to another account using the Java library [Web3j](https://web3j.io/).\\\\n\\\\n## 1. Retrieve public information about an account\\\\n\\\\nThe Ethereum blockchain is a public shared ledger which we can query to retrieve information about the state at a different time, or block number.\\\\n\\\\n### Get account's balance\\\\n\\\\nEvery account has a balance of the Ethereum native cryptocurrency called **Ether**. Using our Web3j instance (see [article-1](#)), it is possible to retrieve the balance of an account at a given block using the function \`web3.ethGetBalance(<accountAddress>, <blockNo>).send()\`\\\\n\\\\nThe balance is stored by default in the smallest denomination of ether called _wei_ (1 ether = 10^18 wei) but Web3j provides a convenience utility class \`Convert\` to convert values between different units.\\\\n\\\\n-   Retrieve the latest balance (latest block) of an account:\\\\n\\\\n\`\`\`java\\\\nEthGetBalance balanceWei = web3.ethGetBalance(\\\\\\"0xF0f15Cedc719B5A55470877B0710d5c7816916b1\\\\\\", DefaultBlockParameterName.LATEST).send();\\\\nSystem.out.println(\\\\\\"balance in wei: \\\\\\" + balanceWei);\\\\n\\\\nBigDecimal balanceInEther = Convert.fromWei(balanceWei.getBalance().toString(), Unit.ETHER);\\\\nSystem.out.println(\\\\\\"balance in ether: \\\\\\" + balanceInEther);\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/S7w0eEH.png)\\\\n\\\\nIn the example above, the latest balance of the account \`0xF0f15Cedc719B5A55470877B0710d5c7816916b1\` is _33.25 ether_.\\\\n\\\\n-   Retrieve the balance of an account at a specific block, if the blockchain you connect to has generated any blocks so far. Test chains may not have yet:\\\\n\\\\n\`\`\`java\\\\nEthGetBalance balance = web3.ethGetBalance(\\\\\\"0xF0f15Cedc719B5A55470877B0710d5c7816916b1\\\\\\", new DefaultBlockParameterNumber(3000000)).send();\\\\n\\\\nBigDecimal balanceInEther = Convert.fromWei(balance.getBalance().toString(), Unit.ETHER);\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/PuUtKHV.png)\\\\n\\\\nThe balance at block #3,000,000 of the account \`0xF0f15Cedc719B5A55470877B0710d5c7816916b1\` is _8.12 ethers_.\\\\n\\\\n### Get account's nonce\\\\n\\\\nAlso included in the state of an account is the _nonce_, a sequence number symbolizing the number of transactions performed by an account.\\\\n\\\\nWeb3j provides the method \`web3.ethGetTransactionCount(<accountAddress>, <blockNo>).send()\` to retrieve the nonce at a given block number, in this case the most recent block.\\\\n\\\\n\`\`\`java\\\\nEthGetTransactionCount ethGetTransactionCount = web3.ethGetTransactionCount(\\\\\\"0xF0f15Cedc719B5A55470877B0710d5c7816916b1\\\\\\", DefaultBlockParameterName.LATEST).send();\\\\n\\\\nBigInteger nonce =  ethGetTransactionCount.getTransactionCount();\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/uJ2bcNk.png)\\\\n\\\\n## 2. Open or create an account\\\\n\\\\nIn order to control an externally owned account and the fund allocated on it, the 32 bytes **Private Key** associated to an account is needed. A private key is a confidential piece of information, so it usually doesn't come in clear text like \`3a1076bf45ab87712ad64ccb3b10217737f7faacbf2872e88fdd9a537d8fe266\` but is secured and encrypted in a wallet. There are many forms of wallets (more or less secured and practical):\\\\n\\\\n![](https://imgur.com/N74l0TI.png)\\\\n\\\\n![](https://imgur.com/m4JjJsM.png)\\\\n\\\\n![](https://imgur.com/X8mANUY.png)\\\\n\\\\nIn this section, we learn how to load an existing wallet and create a new one with Web3j to instanciate a \`Credentials\` object which we can use to sign and send transactions securely on the Ethereum blockchain.\\\\n\\\\n### Load a wallet\\\\n\\\\n#### From a JSON encryted keystore\\\\n\\\\nThe first form of wallet is the JSON encryted keystore, which is a password-encrypted version of the private key. This is the most standard way used by clients such as [Pantheon](https://pegasys.tech/) or [Geth](https://geth.ethereum.org/), but also by online tools like [MyEtherWallet](https://www.myetherwallet.com/) to secure a private key from potential attackers.\\\\n\\\\nWeb3j provides a utility class called \`WalletUtils\` to load a wallet into a \`Credentials\` object (wrapper containing the account address and the keypair).\\\\n\\\\n\`\`\`java\\\\nString walletPassword = \\\\\\"secr3t\\\\\\";\\\\nString walletDirectory = \\\\\\"/path/to/wallets\\\\\\";\\\\nString walletName = \\\\\\"UTC--2019-06-20T08-55-56.200000000Z--fd7d68e16ef61868f3e325fafdf2fc1ec0b77649.json\\\\\\";\\\\n\\\\n// Load the JSON encryted wallet\\\\nCredentials credentials = WalletUtils.loadCredentials(walletPassword, walletDirectory + \\\\\\"/\\\\\\" + walletName);\\\\n\\\\n// Get the account address\\\\nString accountAddress = credentials.getAddress();\\\\n\\\\n// Get the unencrypted private key into hexadecimal\\\\nString privateKey = credentials.getEcKeyPair().getPrivateKey().toString(16);\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/p92p616.png)\\\\n\\\\n#### From a Mnemonic phrase\\\\n\\\\nAnother common form of private key is the **Mnemonic sentence** (or seed phrase) which converts the 32 bytes key to a group of 12 easy to remember words. For example: \`candy maple cake sugar pudding cream honey rich smooth crumble sweet treat\`. This form was established by Bitcoin under the proposal [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).\\\\n\\\\nA mnemonic controls multiple private keys because of a mechanism to derive deterministically the mnemonic from a path.\\\\n\\\\nWe can optionally encrypt the mnemonic with a password.\\\\n\\\\n\`\`\`java\\\\nString password = null; // no encryption\\\\nString mnemonic = \\\\\\"candy maple cake sugar pudding cream honey rich smooth crumble sweet treat\\\\\\";\\\\n\\\\nCredentials credentials = WalletUtils.loadBip39Credentials(password, mnemonic);\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/xN2Ruaj.png)\\\\n\\\\nBy default, Web3j uses a derivation path equal to \`m/44'/60'/0'/1\` (read [this article](https://medium.com/myetherwallet/hd-wallets-and-derivation-paths-explained-865a643c7bf2) to understand _derivation path_). However, it is possible to open another account on a different path:\\\\n\\\\n\`\`\`java\\\\nString password = null; // no encryption\\\\nString mnemonic = \\\\\\"candy maple cake sugar pudding cream honey rich smooth crumble sweet treat\\\\\\";\\\\n\\\\n//Derivation path wanted: // m/44'/60'/0'/0\\\\nint[] derivationPath = {44 | Bip32ECKeyPair.HARDENED_BIT, 60 | Bip32ECKeyPair.HARDENED_BIT, 0 | Bip32ECKeyPair.HARDENED_BIT, 0,0};\\\\n\\\\n// Generate a BIP32 master keypair from the mnemonic phrase\\\\nBip32ECKeyPair masterKeypair = Bip32ECKeyPair.generateKeyPair(MnemonicUtils.generateSeed(mnemonic, password));\\\\n\\\\n// Derived the key using the derivation path\\\\nBip32ECKeyPair  derivedKeyPair = Bip32ECKeyPair.deriveKeyPair(masterKeypair, derivationPath);\\\\n\\\\n// Load the wallet for the derived key\\\\nCredentials credentials = Credentials.create(derivedKeyPair);\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/eEgEdOY.png)\\\\n\\\\n#### From a Private key\\\\n\\\\nAs mentioned before, a private key is a 32 bytes long number. To parse a private key with Web3j, we need to pass the private key to the class \`Credentials\`.\\\\n\\\\n\`\`\`java\\\\nString pk = \\\\\\"c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3\\\\\\";\\\\n\\\\nCredentials credentials = Credentials.create(pk);\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/svlvLnF.png)\\\\n\\\\n### Create a wallet\\\\n\\\\nFinally, if we don't already have an account and want to create a new one from scratch. Web3j's \`WalletUtils\` offers a method to create a JSON encrypted keystore.\\\\n\\\\n\`\`\`java\\\\nString walletPassword = \\\\\\"secr3t\\\\\\";\\\\nString walletDirectory = \\\\\\"/path/to/destination/\\\\\\";\\\\n\\\\nString walletName = WalletUtils.generateNewWalletFile(password, new File(directory));\\\\nSystem.out.println(\\\\\\"wallet location: \\\\\\" + directory + \\\\\\"/\\\\\\" + walletName);\\\\n\\\\n\\\\nCredentials credentials = WalletUtils.loadCredentials(password, directory + \\\\\\"/\\\\\\" + walletName);\\\\n\\\\nString accountAddress = credentials.getAddress();\\\\nSystem.out.println(\\\\\\"Account address: \\\\\\" + credentials.getAddress());\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/kbcemsH.png)\\\\n\\\\n## 3. Send a transaction\\\\n\\\\nNow we have learned how to retrieve public information (state), like the balance from an account and how to open an account using different methods, we can send a transaction to another account.\\\\n\\\\nA transaction on the Ethereum blockchain is composed of the following information:\\\\n\\\\n-   **nonce:** a count of the number of transaction sent by the sender.\\\\n-   **gasPrice (in wei):** the amount the sender is willing to pay per unit of gas required to execute the transaction.\\\\n-   **gasLimit:** the maximum amount of gas the sender is willing to pay to execute this transaction.\\\\n-   **to:** The address of the recipient account.\\\\n-   **value (in wei):** the amount of Wei to transfer from the sender to the recipient. In a contract-creating transaction, this value serves as the starting balance within the newly created contract account.\\\\n-   **signature:** Cryptographic signature that identified the sender of the transaction (from).\\\\n-   **data:** Optional field used to communicate with a smart contract (encoded string including the function name and the parameters).\\\\n\\\\nThere are two ways to send a transaction to the blockchain:\\\\n\\\\n-   **Via the Ethereum node:**\\\\n    This involves sending a non-signed transaction to the Ethereum client having the account _unlocked_.\\\\n    **_I personnaly don't recommend this method which might put your account at risk if the Ethereum node isn't correctly protected_**\\\\n\\\\n-   **Offline transaction:**\\\\n    The concept is to first construct the transaction object \`rawTransaction\` and sign it with a private key (Web3j Credential). Secondly send it to the Ethereum node via the JSON-RPC API to propagate across the network.\\\\n\\\\nOnce a transaction is broadcast to the network, a transaction hash is returned to the client but the transaction isn't performed yet. A set of miners/validators present on the network pick up all the pending transactions, group them into the next block and agree on the validity. Once verified, the transaction is mined into the new block. At this point, the client can claim a transaction receipt by transaction hash to aknowledge the good execution of his transaction.\\\\n\\\\n![](https://web3j.readthedocs.io/en/latest/_images/web3j_transaction.png)\\\\n\\\\n### Send funds from one account to another\\\\n\\\\n#### 1. Load an account and get the nonce\\\\n\\\\nAs explained in the previous sections, we need to load an account from one the methods and retrieve the nonce value of this account:\\\\n\\\\n\`\`\`java\\\\nString walletPassword = \\\\\\"secr3t\\\\\\";\\\\nString walletPath = \\\\\\"/path/to/wallet/UTC--2019-06-20T11-41-39.478000000Z--256c75c85f9c27ac5b2a22f085d9643f7ed91dc1.json\\\\\\";\\\\n\\\\n// Decrypt and open the wallet into a Credential object\\\\nCredentials credentials = WalletUtils.loadCredentials(walletPassword, walletPath);\\\\n\\\\n// Get nonce\\\\nEthGetTransactionCount ethGetTransactionCount = web3.ethGetTransactionCount(credentials.getAddress(), DefaultBlockParameterName.LATEST).send();\\\\nBigInteger nonce =  ethGetTransactionCount.getTransactionCount();\\\\n\`\`\`\\\\n\\\\n#### 2. Configure recipient account and amount to send\\\\n\\\\nIn the next step, we configure the amount (in Wei) to send to a recipient account.\\\\n\\\\n\`\`\`java\\\\n// Recipient account\\\\nString recipientAddress = \\\\\\"0xDD6325C45aE6fAbD028D19fa1539663Df14813a8\\\\\\";\\\\n\\\\n// Value to Transfer\\\\nBigInteger value = Convert.toWei(\\\\\\"1\\\\\\", Unit.ETHER).toBigInteger();\\\\n\`\`\`\\\\n\\\\n#### 3. Configure Gas parameters\\\\n\\\\nGas represents the fees of the network which taken by the miner who mines the block which includes your transaction.\\\\n\\\\nWhen sending a transaction, two parameters are important:\\\\n\\\\n-   **Gas Limit (in unit):** Gas limit refers to the maximum amount of gas you're willing to spend on a particular transaction. After the transaction is executed, if too much gas (\`gasLimit\`) was sent, the remaining gas is refunded to the sender.\\\\n\\\\n-   **Gas Price (in wei):** Amount of Ether you're willing to pay for every unit of gas\\\\n\\\\n\`\`\`java\\\\n// A transfer cost 21,000 units of gas\\\\nBigInteger gasLimit = BigInteger.valueOf(21000);\\\\n\\\\n// I am willing to pay 1Gwei (1,000,000,000 wei or 0.000000001 ether) for each unit of gas consumed by the transaction.\\\\nBigInteger gasPrice = Convert.toWei(\\\\\\"1\\\\\\", Unit.GWEI).toBigInteger();\\\\n\`\`\`\\\\n\\\\n#### 4. Prepare the raw transaction\\\\n\\\\nA raw transaction for a transfer of funds contains all the transaction data fields except:\\\\n\\\\n-   **data**: not a smart contract transaction\\\\n-   **signature**: signature not signed yet\\\\n\\\\n\`\`\`java\\\\n// Prepare the rawTransaction\\\\nRawTransaction rawTransaction  = RawTransaction.createEtherTransaction(\\\\n\\\\tnonce,\\\\n\\\\tgasPrice,\\\\n\\\\tgasLimit,\\\\n\\\\trecipientAddress,\\\\n\\\\tvalue);\\\\n\`\`\`\\\\n\\\\n#### 5. Signature\\\\n\\\\nThe signing part requires the \`rawTransaction\` as well as the \`credentials\` (keypair) used to cryptographically sign the transaction.\\\\n\\\\n\`\`\`java\\\\n// Sign the transaction\\\\nbyte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);\\\\n\\\\n// Convert it to Hexadecimal String to be sent to the node\\\\nString hexValue = Numeric.toHexString(signedMessage);\\\\n\`\`\`\\\\n\\\\n#### 6. Send to the node via JSON-RPC\\\\n\\\\nThe final step consists of sending the transaction signed to the node so it can be verified and broadcast to the network. In case of success, the method returns a response composed of the transaction hash.\\\\n\\\\n\`\`\`java\\\\n// Send transaction\\\\nEthSendTransaction ethSendTransaction = web3.ethSendRawTransaction(hexValue).send();\\\\n\\\\n// Get the transaction hash\\\\nString transactionHash = ethSendTransaction.getTransactionHash();\\\\n\`\`\`\\\\n\\\\n#### 7. Wait for the transaction to be mined.\\\\n\\\\nAs explained before, when the signed transaction is propagated to the network, depending on many factors (gas price, network congestion) it can take some time to see the transaction mined and added to the last block.\\\\n\\\\nThat's why the following code consists of a simple loop to verify every 3 seconds if the transaction is mined by calling the method \`web3.ethGetTransactionReceipt(<txhash>).send()\`.\\\\n\\\\n\`\`\`java\\\\n// Wait for transaction to be mined\\\\nOptional<TransactionReceipt> transactionReceipt = null;\\\\ndo {\\\\n  EthGetTransactionReceipt ethGetTransactionReceiptResp = web3.ethGetTransactionReceipt(transactionHash).send();\\\\n  transactionReceipt = ethGetTransactionReceiptResp.getTransactionReceipt();\\\\n\\\\n  Thread.sleep(3000); // Retry after 3 sec\\\\n} while(!transactionReceipt.isPresent());\\\\n\`\`\`\\\\n\\\\n#### Result\\\\n\\\\nHere is the full version of the code including everything explained in this article:\\\\n\\\\n\`\`\`java\\\\n// Transaction.java\\\\npackage io.kauri.tutorials.java_ethereum;\\\\n\\\\nimport java.io.IOException;\\\\nimport java.math.BigInteger;\\\\nimport java.util.Optional;\\\\n\\\\nimport org.web3j.crypto.Credentials;\\\\nimport org.web3j.crypto.RawTransaction;\\\\nimport org.web3j.crypto.TransactionEncoder;\\\\nimport org.web3j.protocol.Web3j;\\\\nimport org.web3j.protocol.core.DefaultBlockParameterName;\\\\nimport org.web3j.protocol.core.methods.response.EthGetTransactionCount;\\\\nimport org.web3j.protocol.core.methods.response.EthGetTransactionReceipt;\\\\nimport org.web3j.protocol.core.methods.response.EthSendTransaction;\\\\nimport org.web3j.protocol.core.methods.response.TransactionReceipt;\\\\nimport org.web3j.protocol.http.HttpService;\\\\nimport org.web3j.utils.Convert;\\\\nimport org.web3j.utils.Convert.Unit;\\\\nimport org.web3j.utils.Numeric;\\\\n\\\\npublic class Transaction {\\\\n\\\\n  public static void main(String[] args)  {\\\\n\\\\n    System.out.println(\\\\\\"Connecting to Ethereum ...\\\\\\");\\\\n    Web3j web3 = Web3j.build(new HttpService(\\\\\\"https://rinkeby.infura.io/v3/083836b2784f48e19e03487eb3209923\\\\\\"));\\\\n    System.out.println(\\\\\\"Successfuly connected to Ethereum\\\\\\");\\\\n\\\\n    try {\\\\n      String pk = \\\\\\"CHANGE_ME\\\\\\"; // Add a private key here\\\\n\\\\n      // Decrypt and open the wallet into a Credential object\\\\n      Credentials credentials = Credentials.create(pk);\\\\n      System.out.println(\\\\\\"Account address: \\\\\\" + credentials.getAddress());\\\\n      System.out.println(\\\\\\"Balance: \\\\\\" + Convert.fromWei(web3.ethGetBalance(credentials.getAddress(), DefaultBlockParameterName.LATEST).send().getBalance().toString(), Unit.ETHER));\\\\n\\\\n      // Get the latest nonce\\\\n      EthGetTransactionCount ethGetTransactionCount = web3.ethGetTransactionCount(credentials.getAddress(), DefaultBlockParameterName.LATEST).send();\\\\n      BigInteger nonce =  ethGetTransactionCount.getTransactionCount();\\\\n\\\\n      // Recipient address\\\\n      String recipientAddress = \\\\\\"0xAA6325C45aE6fAbD028D19fa1539663Df14813a8\\\\\\";\\\\n\\\\n      // Value to transfer (in wei)\\\\n      BigInteger value = Convert.toWei(\\\\\\"1\\\\\\", Unit.ETHER).toBigInteger();\\\\n\\\\n      // Gas Parameters\\\\n      BigInteger gasLimit = BigInteger.valueOf(21000);\\\\n      BigInteger gasPrice = Convert.toWei(\\\\\\"1\\\\\\", Unit.GWEI).toBigInteger();\\\\n\\\\n      // Prepare the rawTransaction\\\\n      RawTransaction rawTransaction  = RawTransaction.createEtherTransaction(\\\\n                 nonce,\\\\n                 gasPrice,\\\\n                 gasLimit,\\\\n                 recipientAddress,\\\\n                 value);\\\\n\\\\n      // Sign the transaction\\\\n      byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);\\\\n      String hexValue = Numeric.toHexString(signedMessage);\\\\n\\\\n      // Send transaction\\\\n      EthSendTransaction ethSendTransaction = web3.ethSendRawTransaction(hexValue).send();\\\\n      String transactionHash = ethSendTransaction.getTransactionHash();\\\\n      System.out.println(\\\\\\"transactionHash: \\\\\\" + transactionHash);\\\\n\\\\n      // Wait for transaction to be mined\\\\n      Optional<TransactionReceipt> transactionReceipt = null;\\\\n      do {\\\\n        System.out.println(\\\\\\"checking if transaction \\\\\\" + transactionHash + \\\\\\" is mined....\\\\\\");\\\\n            EthGetTransactionReceipt ethGetTransactionReceiptResp = web3.ethGetTransactionReceipt(transactionHash).send();\\\\n            transactionReceipt = ethGetTransactionReceiptResp.getTransactionReceipt();\\\\n            Thread.sleep(3000); // Wait 3 sec\\\\n      } while(!transactionReceipt.isPresent());\\\\n\\\\n      System.out.println(\\\\\\"Transaction \\\\\\" + transactionHash + \\\\\\" was mined in block # \\\\\\" + transactionReceipt.get().getBlockNumber());\\\\n      System.out.println(\\\\\\"Balance: \\\\\\" + Convert.fromWei(web3.ethGetBalance(credentials.getAddress(), DefaultBlockParameterName.LATEST).send().getBalance().toString(), Unit.ETHER));\\\\n\\\\n\\\\n    } catch (IOException | InterruptedException ex) {\\\\n      throw new RuntimeException(ex);\\\\n    }\\\\n  }\\\\n}\\\\n\`\`\`\\\\n\\\\n![](https://imgur.com/8XU21KA.gif)\\\\n\\\\nNow we understand the core principles behind sending transactions with Web3j, I can tell you a secret. Web3j provides a Utility class called 'Transfer' which takes care of everything (nonce, gas, transaction receipt polling, etc.) in one line of code.\\\\n\\\\n\`\`\`java\\\\nTransactionReceipt receipt = Transfer.sendFunds(web3, credentials, recipientAddress, BigDecimal.valueOf(1), Unit.ETHER).send();\\\\n\`\`\`\\\\n\\\\n## Summary\\\\n\\\\nIn this article, we learnt that the Ethereum Global State is composed of a mapping of all accounts states. We can query each account state can be queried to get information like the balance and the nonce.\\\\n\\\\nAn account is controlled by the person owning the private key of this account. The private key can have many forms and is usually secured in a wallet. Web3j allows to open a wallet from a JSON encrypted file, a mnemonic phrase or directly from the private key.\\\\n\\\\nTo send a transaction between two accounts, Web3j can generate a transaction oject, sign it and propagate it to the network to poll the Blockchain to get the transaction receipt when it's been mined.\\\\n\\\\n## Resources\\\\n\\\\n-   [Ethereum Unit converter (WEI, GWEI, ETHER, ....)](https://etherconverter.online/)\\\\n-   [Web3j Transaction doc](https://web3j.readthedocs.io/en/latest/transactions.html#transaction-signing-via-an-ethereum-client)\\\\n-   [Web3j RawTransaction Integration Tests](https://github.com/web3j/web3j/blob/master/integration-tests/src/test/java/org/web3j/protocol/scenarios/CreateRawTransactionIT.java)\\\\n-   [Ethereum - What is Gas Price and Limit](https://masterthecrypto.com/ethereum-what-is-gas-gas-limit-gas-price/)\\\\n-   [Diving into Ethereum World State](https://medium.com/cybermiles/diving-into-ethereums-world-state-c893102030ed)\\\\n\\\\n\\\\n-------------------------------------------\\\\n\\\\n**Next Steps:**\\\\n- [Generate a Java Wrapper from your Smart Contract](https://kauri.io/article/84475132317d4d6a84a2c42eb9348e4b)\\\\n- [Interacting with an Ethereum Smart Contract in Java](https://kauri.io/article/14dc434d11ef4ee18bf7d57f079e246e)\\\\n- [Listening for Ethereum Smart Contract Events in Java](https://kauri.io/article/760f495423db42f988d17b8c145b0874)\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\"}",
              "contributors": Array [
                Object {
                  "__typename": "PublicUserDTO",
                  "avatar": "https://api.dev.kauri.io:443/ipfs/QmXa9LzhDV4wiF9YLsv2Z9CBUaSU6ph8QLNRLTDAUBsrA8",
                  "id": "f0f15cedc719b5a55470877b0710d5c7816916b1",
                  "name": "Grégoire Jeanmart",
                  "username": "gregjeanmart",
                },
              ],
              "dateCreated": "2019-07-19T15:42:45.466Z",
              "datePublished": "2019-07-19T15:42:48.882Z",
              "description": "Other articles in this series: - Connecting to an Ethereum client with Java, Eclipse and Web3j - Generate a Java Wrapper from your Smart Contract - Interacting with an Ethereum Smart Contract in Java - Listening for Ethereum Smart Contract Events in Java - Using Pantheon, the Java Ethereum Client with Linux The Ethereum blockchain is often compared to a World Computer with a global state. The global state grows after each new block and cosists of many accounts organised in a Merkle tree. Each ac",
              "id": "925d923e12c543da9a0a3e617be963b4",
              "owner": Object {
                "__typename": "CommunityDTO",
                "avatar": "https://api.kauri.io:443/ipfs/QmQ9to7bfbR6ADTG2tAKVxWTNw8o3YbwJ1LzdpEJeanLBX",
                "id": "5d2f30daaba2920001c82409",
                "name": "Java Ethereum",
                "resourceIdentifier": Object {
                  "__typename": "ResourceIdentifier",
                  "id": "5d2f30daaba2920001c82409",
                  "type": "COMMUNITY",
                },
              },
              "resourceIdentifier": Object {
                "__typename": "ResourceIdentifier",
                "id": "925d923e12c543da9a0a3e617be963b4",
                "type": "ARTICLE",
              },
              "status": "PUBLISHED",
              "title": "Manage an Ethereum account with Java and Web3j",
              "version": 3,
              "voteResult": Object {
                "__typename": "VoteResultDTO",
                "sum": 0,
              },
            },
            Object {
              "__typename": "ArticleDTO",
              "attributes": Object {
                "background": "https://api.kauri.io:443/ipfs/QmTfBi56eSEH6PnX1fK7aYsQWv6Tq4mja1KH3Yxk8NFzJ5",
              },
              "author": Object {
                "__typename": "PublicUserDTO",
                "avatar": "https://api.dev.kauri.io:443/ipfs/QmXa9LzhDV4wiF9YLsv2Z9CBUaSU6ph8QLNRLTDAUBsrA8",
                "id": "f0f15cedc719b5a55470877b0710d5c7816916b1",
                "name": "Grégoire Jeanmart",
                "username": "gregjeanmart",
              },
              "content": "{\\"markdown\\":\\"\\\\n\\\\n**Other articles in this series:**\\\\n- [Connecting to an Ethereum client with Java, Eclipse and Web3j](https://kauri.io/article/b9eb647c47a546bc95693acc0be72546)\\\\n- [Manage an Ethereum account with Java and Web3j](https://kauri.io/article/925d923e12c543da9a0a3e617be963b4)\\\\n- [Interacting with an Ethereum Smart Contract in Java](https://kauri.io/article/14dc434d11ef4ee18bf7d57f079e246e)\\\\n- [Listening for Ethereum Smart Contract Events in Java](https://kauri.io/article/760f495423db42f988d17b8c145b0874)\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\\\n\\\\n-------------------------------------------\\\\n\\\\n\\\\nIn this article, we discover how to generate a [Java Wrapper Class](https://www.baeldung.com/java-wrapper-classes) directly from a smart contract to interact with a smart contract in Java.\\\\n\\\\nThere are different methods to generate a Java Wrapper Class from a Smart Contract:\\\\n\\\\n-   The [Web3j Command Line tool](https://web3j.readthedocs.io/en/latest/command_line.html) and solc\\\\n-   The Web3j Command Line tool and the artifacts generated by a Truffle build\\\\n-   The [web3j-maven-plugin](https://github.com/web3j/web3j-maven-plugin)\\\\n-   The [web3j-gradle-plugin](https://github.com/web3j/web3j-gradle-plugin)\\\\n\\\\nTo show how to use the methods above, this tutorial uses the following Smart Contract which notarizes documents into a registry on the Ethereum Blockchain.\\\\n\\\\n_DocumentRegistry.sol_\\\\n\\\\n\`\`\`solidity\\\\npragma solidity ^0.5.6;\\\\n\\\\n\\\\n/**\\\\n*  @dev Smart Contract responsible to notarize documents on the Ethereum Blockchain\\\\n*/\\\\ncontract DocumentRegistry {\\\\n\\\\n  struct Document {\\\\n      address signer; // Notary\\\\n      uint date; // Date of notarization\\\\n      bytes32 hash; // Document Hash\\\\n  }\\\\n\\\\n  /**\\\\n   *  @dev Storage space used to record all documents notarized with metadata\\\\n   */\\\\n  mapping(bytes32 => Document) registry;\\\\n\\\\n  /**\\\\n   *  @dev Notarize a document identified by its 32 bytes hash by recording the hash, the sender and date in the registry\\\\n   *  @dev Emit an event Notarized in case of success\\\\n   *  @param _documentHash Document hash\\\\n   */\\\\n  function notarizeDocument(bytes32 _documentHash) external returns (bool) {\\\\n    registry[_documentHash].signer = msg.sender;\\\\n    registry[_documentHash].date = now;\\\\n    registry[_documentHash].hash = _documentHash;\\\\n\\\\n    emit Notarized(msg.sender, _documentHash);\\\\n\\\\n    return true;\\\\n  }\\\\n\\\\n  /**\\\\n   *  @dev Verify a document identified by its hash was noterized in the registry.\\\\n   *  @param _documentHash Document hash\\\\n   *  @return bool if document was noterized previsouly in the registry\\\\n   */\\\\n  function isNotarized(bytes32 _documentHash) external view returns (bool) {\\\\n    return registry[_documentHash].hash ==  _documentHash;\\\\n  }\\\\n\\\\n  /**\\\\n   *  @dev Definition of the event triggered when a document is successfully notarized in the registry\\\\n   */\\\\n  event Notarized(address indexed _signer, bytes32 _documentHash);\\\\n}\\\\n\`\`\`\\\\n\\\\n## Method 1 - Web3j Command Line tool and solc\\\\n\\\\nThis first method generates the Smart contract ABI and bytecode from with \`solc\` and gives those two files as input to \`web3j-cli\` to generate the Wrapper.\\\\n\\\\n### 1. Install solc and verify the version\\\\n\\\\n[Install solc](https://solidity.readthedocs.io/en/develop/installing-solidity.html) and run the command below to make sure the solc version is greater than or equal to \`0.5.6\` (the version specified in the smart contract).\\\\n\\\\n\`\`\`shell\\\\n$ solc --version\\\\nsolc, the solidity compiler commandline interface\\\\nVersion: 0.5.9+commit.c68bc34e.Linux.g++\\\\n\`\`\`\\\\n\\\\n### 2. Install web3j-cli\\\\n\\\\nTo install the web3j-cli, download a zipfile/tarball from the [releases](https://github.com/web3j/web3j/releases/latest) page of the project repository, under the **Downloads** section, or for macOS users via [Homebrew](https://github.com/web3j/homebrew-web3j), or for Arch linux users via the [AUR](https://aur.archlinux.org/packages/web3j/).\\\\n\\\\n\`\`\`bash\\\\nbrew tap web3j/web3j\\\\nbrew install web3j\\\\nweb3j\\\\n\`\`\`\\\\n\\\\nTo run via a zipfile, extract it and run the binary, you may also want to add the binary to your \`PATH\`:\\\\n\\\\n\`\`\`shell\\\\n$ unzip web3j-4.3.0.zip\\\\n    creating: web3j-4.3.0/lib/\\\\n    inflating: web3j-4.3.0/lib/core-1.0.2-all.jar\\\\n    creating: web3j-4.3.0/bin/\\\\n    inflating: web3j-4.3.0/bin/web3j\\\\n    inflating: web3j-4.3.0/bin/web3j.bat\\\\n$ ./web3j-<version>/bin/web3j\\\\n\\\\n                _      _____ _     _\\\\n            | |    |____ (_)   (_)\\\\n__      _____| |__      / /_     _   ___\\\\n\\\\\\\\ \\\\\\\\ /\\\\\\\\ / / _ \\\\\\\\ '_ \\\\\\\\     \\\\\\\\ \\\\\\\\ |   | | / _ \\\\\\\\\\\\n\\\\\\\\ V  V /  __/ |_) |.___/ / | _ | || (_) |\\\\n    \\\\\\\\_/\\\\\\\\_/ \\\\\\\\___|_.__/ \\\\\\\\____/| |(_)|_| \\\\\\\\___/\\\\n                        _/ |\\\\n                        |__/\\\\n\\\\nUsage: web3j version|wallet|solidity ...\\\\n\`\`\`\\\\n\\\\n### 3. Compile the smart contract with solc\\\\n\\\\nGiven our Solidity file _DocumentRegistry.sol_, the \`solc <sol> --bin --abi --optimize -o <output>\` command compiles the smart contract and generates two new files in the same directory :\\\\n\\\\n\`\`\`shell\\\\n$ solc DocumentRegistry.sol --bin --abi --optimize -o ./\\\\nCompiler run successful. Artifact(s) can be found in directory ./.\\\\n\\\\n$ ls -l\\\\ntotal 12\\\\n-rw-rw-r-- 1 gjeanmart gjeanmart  565 Jun 24 13:42 DocumentRegistry.abi\\\\n-rw-rw-r-- 1 gjeanmart gjeanmart  676 Jun 24 13:42 DocumentRegistry.bin\\\\n-rw-rw-r-- 1 gjeanmart gjeanmart 1488 Jun 24 13:40 DocumentRegistry.sol\\\\n\`\`\`\\\\n\\\\n-   _DocumentRegistry.bin_: Binary file, bytecode of the smart contract\\\\n-   _DocumentRegistry.abi_: ABI (Application Binary Interface) of the smart contract which defines the interface in a JSON format.\\\\n\\\\n### 4. Generate the Wrapper with the web3j-cli\\\\n\\\\nUsing the ABI and bytecode (generated in step 3) and \`web3j-cli\` (installed during step 2), we can now generate our Smart contract Java Wrapper with the following command:\\\\n\\\\n\`\`\`shell\\\\nweb3j solidity generate -a=<abiFile> -b=<binFile> -o=<destinationFileDir> -p=<packageName>\\\\n\`\`\`\\\\n\\\\nFor example:\\\\n\\\\n\`\`\`shell\\\\n$ web3j solidity generate -a DocumentRegistry.abi  -b DocumentRegistry.bin -o . -p me.gjeanmart.tutorials.javaethereum.wrapper\\\\n\\\\n              _      _____ _     _\\\\n             | |    |____ (_)   (_)\\\\n__      _____| |__      / /_     _   ___\\\\n\\\\\\\\ \\\\\\\\ /\\\\\\\\ / / _ \\\\\\\\ '_ \\\\\\\\     \\\\\\\\ \\\\\\\\ |   | | / _ \\\\\\\\\\\\n \\\\\\\\ V  V /  __/ |_) |.___/ / | _ | || (_) |\\\\n  \\\\\\\\_/\\\\\\\\_/ \\\\\\\\___|_.__/ \\\\\\\\____/| |(_)|_| \\\\\\\\___/\\\\n                         _/ |\\\\n                        |__/\\\\n\\\\nGenerating me.gjeanmart.tutorials.javaethereum.wrapper.DocumentRegistry ... File written to .\\\\n\`\`\`\\\\n\\\\nAs a result, you should see the Java Wrapper file generated into the folder _<package-folders>/<contract>.java_ that you can copy to the _src/main/java/_ folder of your project.\\\\n\\\\n\`\`\`shell\\\\n./me/gjeanmart/tutorials/javaethereum/wrapper/DocumentRegistry.java\\\\n\`\`\`\\\\n\\\\n## Method 2 - Web3j Command Line tool and Truffle artefacts\\\\n\\\\n[**Truffle**](https://www.trufflesuite.com/truffle) is one of the most well-known frameworks to help you develop, test and deploy with Ethereum. We can use the artefacts that Truffle generates with the Web3j command line tool to create the wrapper class.\\\\n\\\\n### 1. Install Truffle\\\\n\\\\nTruffle is available as an npm package.\\\\n\\\\n\`\`\`shell\\\\n$ npm install truffle -g\\\\n- Fetching solc version list from solc-bin. Attempt #1\\\\n+ truffle@5.0.24\\\\nadded 27 packages from 439 contributors in 11.636s\\\\n\\\\n$ truffle version\\\\nTruffle v5.0.24 (core: 5.0.24)\\\\nSolidity v0.5.0 (solc-js)\\\\nNode v10.15.3\\\\nWeb3.js v1.0.0-beta.37\\\\n\`\`\`\\\\n\\\\n### 2. Initialize a new Truffle project\\\\n\\\\nTo initialize a Truffle project, use the command \`truffle init\` in a new folder. The command creates the folders _contracts/_, _migration/_ and _test/_, and the file _truffle-config.js_.\\\\n\\\\n\`\`\`shell\\\\n$ mkdir truffle\\\\n$ cd truffle\\\\n$ truffle init\\\\n\\\\n? Preparing to download\\\\n? Downloading\\\\n? Cleaning up temporary files\\\\n? Setting up box\\\\n\\\\nUnbox successful. Sweet!\\\\n\\\\nCommands:\\\\n\\\\n  Compile:        truffle compile\\\\n  Migrate:        truffle migrate\\\\n  Test contracts: truffle test\\\\n\\\\n$ ls -l\\\\ntotal 20\\\\ndrwxrwxr-x 2 gjeanmart gjeanmart 4096 Jun 24 14:25 contracts\\\\ndrwxrwxr-x 2 gjeanmart gjeanmart 4096 Jun 24 14:25 migrations\\\\ndrwxrwxr-x 2 gjeanmart gjeanmart 4096 Jun 24 14:25 test\\\\n-rw-rw-r-- 1 gjeanmart gjeanmart 4233 Jun 24 14:25 truffle-config.js\\\\n\`\`\`\\\\n\\\\n### 3. Add the contract into the folder \`contracts\`\\\\n\\\\nCopy the Smart Contract source _DocumentRegistry.sol_ into the folder _contracts_.\\\\n\\\\n### 4. Compile the contract\\\\n\\\\nCompile the smart contract with the command \`truffle compile\`, this command generates a new folder _build/contracts/_, containing a Truffle artefact for each Smart contract compiled.\\\\n\\\\n\`\`\`shell\\\\n$ truffle compile\\\\n\\\\nCompiling your contracts...\\\\n===========================\\\\n> Compiling ./contracts/DocumentRegistry.sol\\\\n> Compiling ./contracts/Migrations.sol\\\\n> Artifacts written to /home/gjeanmart/workspace/tutorials/java-ethereum-wrapper/truffle/build/contracts\\\\n> Compiled successfully using:\\\\n   - solc: 0.5.8+commit.23d335f2.Emscripten.clang\\\\n\\\\n$ ls -l build/contracts/\\\\ntotal 136\\\\n-rw-rw-r-- 1 gjeanmart gjeanmart 79721 Jun 24 14:33 DocumentRegistry.json\\\\n-rw-rw-r-- 1 gjeanmart gjeanmart 54043 Jun 24 14:33 Migrations.json\\\\n\`\`\`\\\\n\\\\n### 5. Generate the Smart Contract Java Wrapper from the Truffle Artefact\\\\n\\\\nFinally, web3j-cli provides a method to generate the Wrapper directly from the Truffle artefact result of \`truffle compile\` with the command:\\\\n\\\\n\`\`\`shell\\\\n$ web3j  truffle generate ./build/contracts/DocumentRegistry.json -o . -p me.gjeanmart.tutorials.javaethereum.wrapper\\\\n\\\\n              _      _____ _     _\\\\n             | |    |____ (_)   (_)\\\\n__      _____| |__      / /_     _   ___\\\\n\\\\\\\\ \\\\\\\\ /\\\\\\\\ / / _ \\\\\\\\ '_ \\\\\\\\     \\\\\\\\ \\\\\\\\ |   | | / _ \\\\\\\\\\\\n \\\\\\\\ V  V /  __/ |_) |.___/ / | _ | || (_) |\\\\n  \\\\\\\\_/\\\\\\\\_/ \\\\\\\\___|_.__/ \\\\\\\\____/| |(_)|_| \\\\\\\\___/\\\\n                         _/ |\\\\n                        |__/\\\\n\\\\nGenerating me.gjeanmart.tutorials.javaethereum.wrapper.DocumentRegistry ... File written to .\\\\n\`\`\`\\\\n\\\\nAs a result, you should see the Java Wrapper file generated into the folder _&lt;package_folders>/<contract>.java_ that you can copy to the _src/main/java/_ folder of your project.\\\\n\\\\n\`\`\`shell\\\\n./me/gjeanmart/tutorials/javaethereum/wrapper/DocumentRegistry.java\\\\n\`\`\`\\\\n\\\\n**Note**: With Truffle you can do a lot more than shown in this post, such as deployment scriptd (migration), Multi-network configuration, testing, debugging. I recommend reading [the following guide](https://kauri.io/collection/5b8e401ee727370001c942e3) to learn more about all the features.\\\\n\\\\n## Method 3 - web3j-maven-plugin\\\\n\\\\nThe next solution is more elegant than the previous two because we don't have to install the webj-cli and copy the file to the source folder. We can use this method directly inside a Java project using Maven and the [**web3j-maven-plugin**](https://github.com/web3j/web3j-maven-plugin). The following steps assume you have created a Maven project.\\\\n\\\\n### 1. Prerequisites\\\\n\\\\n[Install solc](https://solidity.readthedocs.io/en/develop/installing-solidity.html) and run the command below to make sure the solc version is greater than or equal to \`0.5.6\` (the version specified in the smart contract).\\\\n\\\\n\`\`\`shell\\\\n$ solc --version\\\\nsolc, the solidity compiler commandline interface\\\\nVersion: 0.5.9+commit.c68bc34e.Linux.g++\\\\n\`\`\`\\\\n\\\\n### 2. Copy the smart contract into the folder _src/main/resources_\\\\n\\\\nCopy the Smart Contract source _DocumentRegistry.sol_ into the _src/main/resources_ folder of the Maven project.\\\\n\\\\n### 3. Configure Maven to generate the Wrapper during the \`generate-sources\` phase\\\\n\\\\nIn this step, we configure two Maven plugins:\\\\n\\\\n#### web3j-maven-plugin\\\\n\\\\nThe first plugin does the same as the two previous methods but integrated with Maven. First we configure the plugin to execute automatically when entering the \`generate-sources\` phase of the project.\\\\n\\\\nSecondly we configure the plugin parameters:\\\\n\\\\n-   _packageName_: Package name to apply to the generated Wrapper classes\\\\n-   _sourceDestination_: Target destination folder to move the generated Wrapper classes\\\\n-   _soliditySourceFiles_: Where to find the Smart Contract source files\\\\n\\\\n#### build-helper-maven-plugin\\\\n\\\\nThe second plugin adds the _sourceDestination_ folder into the classpath so we can import the generated Wrapper classes\\\\n\\\\n_pom.xml_\\\\n\\\\n\`\`\`xml\\\\n<build>\\\\n    <plugins>\\\\n        <plugin>\\\\n            <groupId>org.web3j</groupId>\\\\n            <artifactId>web3j-maven-plugin</artifactId>\\\\n            <version>4.2.0</version>\\\\n            <executions>\\\\n                <execution>\\\\n                    <id>generate-sources-web3j</id>\\\\n                    <phase>generate-sources</phase>\\\\n                    <goals>\\\\n                        <goal>generate-sources</goal>\\\\n                    </goals>\\\\n                    <configuration>\\\\n                        <packageName>me.gjeanmart.tutorials.javaethereum.contracts.generated</packageName>\\\\n                        <sourceDestination>\${basedir}/target/generated-sources/contracts</sourceDestination>\\\\n                        <soliditySourceFiles>\\\\n                            <directory>\${basedir}/src/main/resources</directory>\\\\n                            <includes>\\\\n                                <include>**/*.sol</include>\\\\n                            </includes>\\\\n                        </soliditySourceFiles>\\\\n                    </configuration>\\\\n                </execution>\\\\n            </executions>\\\\n        </plugin>\\\\n\\\\n        <plugin>\\\\n            <groupId>org.codehaus.mojo</groupId>\\\\n            <artifactId>build-helper-maven-plugin</artifactId>\\\\n            <executions>\\\\n                <execution>\\\\n                    <id>add-source</id>\\\\n                    <phase>generate-sources</phase>\\\\n                    <goals>\\\\n                        <goal>add-source</goal>\\\\n                    </goals>\\\\n                    <configuration>\\\\n                        <sources>\\\\n                            <source>\${basedir}/target/generated-sources/contracts</source>\\\\n                        </sources>\\\\n                    </configuration>\\\\n                </execution>\\\\n            </executions>\\\\n        </plugin>\\\\n    </plugins>\\\\n</build>\\\\n\`\`\`\\\\n\\\\n### 4. Run Maven generate-sources\\\\n\\\\nFinally, build the Maven project by using, for example \`mvn clean package\` (including the generate-sources phase). As a result, we can see the Java Wrapper has been generated into \`/target/generated-sources/contracts/me/gjeanmart/tutorials/javaethereum/contracts/generated/DocumentRegistry.java\` and added to the classpath automatically.\\\\n\\\\n![](https://imgur.com/nBMOWGq.png)\\\\n\\\\n## Method 4 - web3j-gradle-plugin\\\\n\\\\nThe last method is similar to the previous method with Maven, but using Gradle instead.\\\\n\\\\n### 1. Prerequisites\\\\n\\\\n[Install solc](https://solidity.readthedocs.io/en/develop/installing-solidity.html) and run the command below to make sure the solc version is greater than or equal to \`0.5.6\` (the version specified in the smart contract).\\\\n\\\\n\`\`\`shell\\\\n$ solc --version\\\\nsolc, the solidity compiler commandline interface\\\\nVersion: 0.5.9+commit.c68bc34e.Linux.g++\\\\n\`\`\`\\\\n\\\\n### 2. Place the smart contract into the folder _src/main/solidity_\\\\n\\\\nCopy the Smart Contract source _DocumentRegistry.sol_ into the folder _src/main/solidity_ of the Gradle project.\\\\n\\\\n### 3. Configure Gradle to generate the Wrapper during build\\\\n\\\\nFirst import the web3j-gradle plugin into the _build.gradle_ file\\\\n\\\\n\`\`\`groovy\\\\nplugins {\\\\n    id 'org.web3j' version '4.3.0'\\\\n}\\\\n\`\`\`\\\\n\\\\nThen we can configure the plugin to specify the package name and the target folder for the generated wrapper classes:\\\\n\\\\n\`\`\`groovy\\\\nweb3j {\\\\n    generatedPackageName = 'me.gjeanmart.tutorials.javaethereum.contracts.generated'\\\\n    generatedFilesBaseDir = \\\\\\"$buildDir/contracts\\\\\\"\\\\n}\\\\n\`\`\`\\\\n\\\\nTo use your system installed version of \`solc\` instead of the version bundled with the plugin, add the following lines to _build.gradle_:\\\\n\\\\n\`\`\`groovy\\\\nsolidity {\\\\n    executable = \\\\\\"solc\\\\\\"\\\\n}\\\\n\`\`\`\\\\n\\\\n_build.gradle_\\\\n\\\\n\`\`\`groovy\\\\n/*\\\\n * This file was generated by the Gradle 'init' task.\\\\n *\\\\n * This generated file contains a sample Java Library project to get you started.\\\\n * For more details take a look at the Java Libraries chapter in the Gradle\\\\n * user guide available at https://docs.gradle.org/5.0/userguide/java_library_plugin.html\\\\n */\\\\n\\\\nplugins {\\\\n    // Apply the java-library plugin to add support for Java Library\\\\n    id 'java-library'\\\\n    id 'org.web3j' version '4.3.0'\\\\n}\\\\n\\\\nrepositories {\\\\n    // Use jcenter for resolving your dependencies.\\\\n    // You can declare any Maven/Ivy/file repository here.\\\\n    jcenter()\\\\n}\\\\n\\\\ndependencies {\\\\n    // This dependency is exported to consumers, that is to say found on their compile classpath.\\\\n    api 'org.apache.commons:commons-math3:3.6.1'\\\\n\\\\n    // This dependency is used internally, and not exposed to consumers on their own compile classpath.\\\\n    implementation 'com.google.guava:guava:26.0-jre'\\\\n    implementation 'org.web3j:core:4.3.0'\\\\n\\\\n    // Use JUnit test framework\\\\n    testImplementation 'junit:junit:4.12'\\\\n}\\\\n\\\\nweb3j {\\\\n    generatedPackageName = 'me.gjeanmart.tutorials.javaethereum.contracts.generated'\\\\n    generatedFilesBaseDir = \\\\\\"$buildDir/contracts\\\\\\"\\\\n}\\\\n\\\\nsolidity {\\\\n    executable = \\\\\\"solc\\\\\\"\\\\n}\\\\n\`\`\`\\\\n\\\\n### 4. Execute gradle build\\\\n\\\\nIn this last step, we execute the build using \`./gradlew tasks --all\` and verify that our generated wrapper classes have been generated.\\\\n\\\\n![](https://imgur.com/dA0sVy1.png)\\\\n\\\\n\\\\n-------------------------------------------\\\\n\\\\n**Next Steps:**\\\\n- [Interacting with an Ethereum Smart Contract in Java](https://kauri.io/article/14dc434d11ef4ee18bf7d57f079e246e)\\\\n- [Listening for Ethereum Smart Contract Events in Java](https://kauri.io/article/760f495423db42f988d17b8c145b0874)\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\\\n\\"}",
              "contributors": Array [
                Object {
                  "__typename": "PublicUserDTO",
                  "avatar": "https://api.dev.kauri.io:443/ipfs/QmXa9LzhDV4wiF9YLsv2Z9CBUaSU6ph8QLNRLTDAUBsrA8",
                  "id": "f0f15cedc719b5a55470877b0710d5c7816916b1",
                  "name": "Grégoire Jeanmart",
                  "username": "gregjeanmart",
                },
              ],
              "dateCreated": "2019-07-19T15:45:43.967Z",
              "datePublished": "2019-07-19T15:45:46.562Z",
              "description": "Other articles in this series: - Connecting to an Ethereum client with Java, Eclipse and Web3j - Manage an Ethereum account with Java and Web3j - Interacting with an Ethereum Smart Contract in Java - Listening for Ethereum Smart Contract Events in Java - Using Pantheon, the Java Ethereum Client with Linux In this article, we discover how to generate a Java Wrapper Class directly from a smart contract to interact with a smart contract in Java. There are different methods to generate a Java Wrappe",
              "id": "84475132317d4d6a84a2c42eb9348e4b",
              "owner": Object {
                "__typename": "CommunityDTO",
                "avatar": "https://api.kauri.io:443/ipfs/QmQ9to7bfbR6ADTG2tAKVxWTNw8o3YbwJ1LzdpEJeanLBX",
                "id": "5d2f30daaba2920001c82409",
                "name": "Java Ethereum",
                "resourceIdentifier": Object {
                  "__typename": "ResourceIdentifier",
                  "id": "5d2f30daaba2920001c82409",
                  "type": "COMMUNITY",
                },
              },
              "resourceIdentifier": Object {
                "__typename": "ResourceIdentifier",
                "id": "84475132317d4d6a84a2c42eb9348e4b",
                "type": "ARTICLE",
              },
              "status": "PUBLISHED",
              "title": "Generate a Java Wrapper from your Smart Contract",
              "version": 3,
              "voteResult": Object {
                "__typename": "VoteResultDTO",
                "sum": 0,
              },
            },
            Object {
              "__typename": "ArticleDTO",
              "attributes": Object {
                "background": "https://api.kauri.io:443/ipfs/QmQBqEvUaNN7ByVMSPrpa2Tw1mMGCCNPYyfai7Z6WE6Fwr",
              },
              "author": Object {
                "__typename": "PublicUserDTO",
                "avatar": "https://api.beta.kauri.io:443/ipfs/QmekAbiDvz3Bc5y4pZB7Gnk5Zgn5iaa5CxQoSmTsDoPkP9",
                "id": "4d91838268f6d6d4e590e8fd2a001cd91c32e7a4",
                "name": "Craig Williams",
                "username": "craig",
              },
              "content": "{\\"markdown\\":\\"\\\\n**Other articles in this series:**\\\\n- [Connecting to an Ethereum client with Java, Eclipse and Web3j](https://kauri.io/article/b9eb647c47a546bc95693acc0be72546)\\\\n- [Manage an Ethereum account with Java and Web3j](https://kauri.io/article/925d923e12c543da9a0a3e617be963b4)\\\\n- [Generate a Java Wrapper from your Smart Contract](https://kauri.io/article/84475132317d4d6a84a2c42eb9348e4b)\\\\n- [Listening for Ethereum Smart Contract Events in Java](https://kauri.io/article/760f495423db42f988d17b8c145b0874)\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\\\n\\\\n-------------------------------------------\\\\n\\\\nIn this tutorial, you will learn how to deploy a smart contract using the Web3j java library, along with how to interact with the functions of the smart contract.\\\\n\\\\nAs a prerequisite, you should be familiar with [account management](https://kauri.io/article/925d923e12c543da9a0a3e617be963b4/manage-an-ethereum-account-with-java-and-web3j) and contract java wrapper generation as described in the [previous article](https://kauri.io/article/84475132317d4d6a84a2c42eb9348e4b/generate-a-java-wrapper-from-your-smart-contract) in this series.  For continuity, we will deploy the same \`DocumentRegistry\` smart contract.\\\\n\\\\n_DocumentRegistry.sol_\\\\n\\\\n\`\`\` solidity\\\\npragma solidity ^0.5.6;\\\\n\\\\n\\\\n/**\\\\n*  @dev Smart Contract resposible to notarize documents on the Ethereum Blockchain\\\\n*/\\\\ncontract DocumentRegistry {\\\\n\\\\n    struct Document {\\\\n        address signer; // Notary\\\\n        uint date; // Date of notarization\\\\n        string hash; // Document Hash\\\\n    }\\\\n\\\\n    /**\\\\n     *  @dev Storage space used to record all documents notarized with metadata\\\\n     */\\\\n    mapping(bytes32 => Document) registry;\\\\n\\\\n    /**\\\\n     *  @dev Notarize a document identified by the hash of the document hash, the sender and date in the registry\\\\n     *  @dev Emit an event Notarized in case of success\\\\n     *  @param _documentHash Document hash\\\\n     */\\\\n    function notarizeDocument(string calldata _documentHash) external returns (bool) {\\\\n        bytes32 id = keccak256(abi.encodePacked(_documentHash));\\\\n\\\\n        registry[id].signer = msg.sender;\\\\n        registry[id].date = now;\\\\n        registry[id].hash = _documentHash;\\\\n\\\\n        emit Notarized(msg.sender, _documentHash);\\\\n\\\\n        return true;\\\\n    }\\\\n\\\\n    /**\\\\n     *  @dev Verify a document identified by its has was noterized in the registry previsouly.\\\\n     *  @param _documentHash Document hash\\\\n     *  @return bool if document was noterized previsouly in the registry\\\\n     */\\\\n    function isNotarized(string calldata _documentHash) external view returns (bool) {\\\\n        return registry[keccak256(abi.encodePacked(_documentHash))].signer != address(0);\\\\n    }\\\\n\\\\n    /**\\\\n     *  @dev Definition of the event triggered when a document is successfully notarized in the registry\\\\n     */\\\\n    event Notarized(address indexed _signer, string _documentHash);\\\\n}\\\\n\`\`\`\\\\n\\\\n## A Brief Primer on Mining and Gas\\\\n\\\\n### Mining\\\\n\\\\nAny interactions with the Ethereum network that update EVM state must be triggered by a transaction that is broadcast to the blockchain.  Some example interactions include sending Ether to another account, deploying a smart contract and some smart contract function invocations.\\\\n\\\\nMiners are entities that secure the Ethereum network by constantly attempting to calculate the answer to a complex mathematical puzzle, a mechanism called Proof-of-Work consensus.\\\\n\\\\nIt is the job of miners to gather a bundle of pending transactions (from the mempool) and create a block that includes these transactions.  Once a transaction is included within a mined block, it is considered executed, and any related state changes will be applied.\\\\n\\\\n### Gas\\\\n\\\\nEther, the native cryptocurrency of Ethereum, is paid by the transaction sender to the miner that included the transaction within a block.  This is one of the ways that miners are incentivized.\\\\n\\\\nGas is a unit of computational work within the Ethereum network, and the amount of Ether paid whilst executing a transaction depends on how much gas is consumed, along with the \`gasPrice\` transaction attribute, which defines how much Ether the sender will pay per gas unit consumed.  Its important to understand that different transactions will require differing amounts of gas, depending on the operation, with each transaction costing a minimum of 21,000 gas.\\\\n\\\\nIt is also possible to define the absolute maximum amount of gas that a transaction sender is willing to consume in order to execute the transaction, by specifying the \`gasLimit\` attribute.\\\\n\\\\n## Deploying\\\\n\\\\nThe ability to deploy immutable smart contracts that live indefinitely is the secret sauce of Ethereum!  Smart contracts are pieces of code with functions that can be executed by any interested parties.  They live as bytecode within the network but are usually written in a language such as [Solidity](https://solidity.readthedocs.io/en) or [Vyper](https://vyper.readthedocs.io), then encoded and deployed.\\\\n\\\\nBy far the easiest way to deploy the \`DocumentRegistry\` smart contract is to use a wrapper that has been generated by Web3j.   This wrapper provides a native java class representation of the smart contract.  Two (non deprecated) \`deploy\` methods that can be used to deploy the code to the Ethereum network are provided:\\\\n\\\\n\`\`\` java\\\\npublic static RemoteCall<DocumentRegistry> deploy(Web3j web3j, Credentials credentials, ContractGasProvider contractGasProvider)\\\\n\`\`\`\\\\n\`\`\` java\\\\npublic static RemoteCall<DocumentRegistry> deploy(Web3j web3j, TransactionManager transactionManager, ContractGasProvider contractGasProvider)\\\\n\`\`\`\\\\n\\\\nThe latter allows the \`TransactionManager\` to be specified; an object which controls how Web3j connects to an Ethereum client.  We're happy to use the default \`RawTransactionManager\` in this example, so we'll use the former method, which takes wallet \`Credentials\` as an argument.  We must also create a \`ContractGasProvider\`, which provides the gas price and gas limit for the transaction; indirectly specifying how much the contract will cost to deploy, in Ether.\\\\n\\\\n_DocumentRegistry Deployment Code_\\\\n\`\`\` java\\\\n//Create credentials from private key\\\\nCredentials creds = Credentials.create(\\\\\\"0x8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63\\\\\\");\\\\n\\\\nDocumentRegistry registryContract = DocumentRegistry.deploy(web3j, creds, new DefaultGasProvider()).send();\\\\n\\\\nString contractAddress = registryContract.getContractAddress();\\\\n\`\`\`\\\\nThe \`deploy\` method returns a \`RemoteCall\` object.  Calling \`send()\` on the \`RemoteCall\` synchronously deploys the smart contract to the Ethereum network, and returns an instance of \`DocumentRegistry\` which is linked to this deployed code.  Every deployed smart contract has a unique Ethereum address associated with it, and this address can be accessed by calling the \`getContractAddress()\` method on the contract wrapper, after deployment.\\\\n\\\\nIn this snippet, the credentials are constructed from a hard coded private key (for address 0xfe3b557e8fb62b89f4916b721be55ceb828dbd73).  This is fine for testing and demonstration purposes, but a production implementation should never hard code a private key, because an attacker will be able to take control of your account.  One approach to overcome this is to set the key as an environment variable on your server, and load this in your code.\\\\n\\\\nThe provided \`DefaultGasProvider\` is used in this example, which sets the gas price and limit to hard coded values, but a custom version can be built by implementing the below interface:\\\\n\\\\n\`\`\` java\\\\npublic interface ContractGasProvider {\\\\n    BigInteger getGasPrice(String contractFunc);\\\\n\\\\n    @Deprecated\\\\n    BigInteger getGasPrice();\\\\n\\\\n    BigInteger getGasLimit(String contractFunc);\\\\n\\\\n    @Deprecated\\\\n    BigInteger getGasLimit();\\\\n}\\\\n\`\`\`\\\\n\\\\n## Creating a Wrapper Instance for an Already Deployed Contract\\\\nMore often than not, the smart contract that you want to interact with will already be deployed to the Ethereum network.  In this scenario, the static \`load(..)\` method can be used:\\\\n\`\`\` java\\\\npublic static DocumentRegistry load(String contractAddress, Web3j web3j, Credentials credentials, ContractGasProvider contractGasProvider)\\\\n\`\`\`\\\\n\`\`\` java\\\\npublic static DocumentRegistry load(String contractAddress, Web3j web3j, TransactionManager transactionManager, ContractGasProvider contractGasProvider)\\\\n\`\`\`\\\\n\\\\nFor example, if our \`DocumentRegistry\` is deployed with the address \`0x10c7dc2b84b6c8e6df5a749655830e70adca3a2b\`, we can obtain a java wrapper for the deployed contract as follows:\\\\n\\\\n\`\`\` java\\\\n//Create credentials from private key\\\\nCredentials creds = Credentials.create(\\\\\\"0x8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63\\\\\\");\\\\n\\\\nDocumentRegistry registryContract = DocumentRegistry.load(web3j, creds, new DefaultGasProvider());\\\\n\`\`\`\\\\n## Invoking a Smart Contract Function\\\\n\\\\n### Transactions vs Calls\\\\n\\\\nA smart contract function can be invoked in 2 different ways, depending on the behaviour of the function.  \\\\n\\\\n#### Transactions\\\\n\\\\nTo invoke a smart contract function that can potentially change contract state (adding / updating / deleting a value), a transaction must be broadcast to the Ethereum network.  The function invocation details such as function name and argument values are encoded in the data field of a transaction in a well known format, and much like a regular Ether value transaction, the invocation will consume gas.  \\\\n\\\\nA miner must choose to include the transaction within a block in order for the function invocation to take place, so therefore transaction executions are asynchronous in nature.  After broadcasting the transaction, a unique hash is returned, which can then be used to request a transaction receipt from the Ethereum client (once it has been included within a block).\\\\n\\\\nFor a detailed explanation of Ethereum transactions, see [this guide](https://medium.com/blockchannel/life-cycle-of-an-ethereum-transaction-e5c66bae0f6e).\\\\n\\\\n#### Calls\\\\n\\\\nA call is local to the Ethereum client that your service is connected to, and does not broadcast anything to the wider Ethereum network.  Because of this, a contract call is free to execute; they do not consume any gas. However, call operations are read only, meaning that any state changes that occur within the smart contract function are not persisted and are rolled back after execution.  There is no mining involved, so executions are synchronous.\\\\n\\\\n### Using the Contract Wrapper\\\\n\\\\nAs was true for deploying, invoking a function using a Web3j generated contract wrapper is by far the easiest approach.  The tricky data encoding is encapsulated and handled for you under the covers.  \\\\n\\\\nA java method is generated that corresponds to each function within your smart contract.  Web3j establishes if the function should be invoked via a transaction or call automatically, at wrapper generation, based on the keywords of the function.  For example, a function definition that includes the \`view\` or \`pure\` keywords will be executed via a call, otherwise its assumed that there will be some potential state changes, and a transaction approach is used.\\\\n\\\\n#### Invoking \`notarizeDocument(..)\`\\\\nIn our \`DocumentRegistry\` example smart contract, the \`notarizeDocument(..)\` function stores the document details in the smart contract state and should therefore be triggered via a transaction in an asynchronous manner.  The generated function signature is:\\\\n\\\\n\`\`\` java\\\\npublic RemoteCall<TransactionReceipt> notarizeDocument(String _documentHash)\\\\n\`\`\`\\\\nInterestingly, even though behind the scenes, a transaction is asynchronously broadcast to the network and included within a block, Web3j handles the transaction receipt polling on your behalf, and so the remote call returned by this method is actually synchronous and blocks until the transaction has been mined, subsequently returning the transaction receipt .  If this behaviour is not desired within your application, you will have to either send a transaction manually without the help of the wrapper, or make the remote call on a different thread.\\\\n\\\\nSo calling the \`notarizeDocument\` function is made very simple with the wrapper, and looks like this:\\\\n\\\\n\`\`\` java\\\\nDocumentRegistry documentRegistry = deployDocumentRegistryContract();\\\\nTransactionReceipt receipt = documentRegistry.notarizeDocument(\\\\n        \\\\\\"QmXoypizjW3WknFiJnKLwHCnL72vedxjQkDDP1mXWo6uco\\\\\\").send();\\\\n\\\\nString txHash = receipt.getTransactionHash();\\\\n\`\`\`\\\\n\\\\nA \`TransactionException\` is thrown if the transaction fails.\\\\n\\\\n#### Invoking \`isNotarized(..)\`\\\\nAs this function is marked as a \`view\` function, this indicates that it is read-only and can therefore be called locally.  The generated method signature is:\\\\n\\\\n\`\`\` java\\\\npublic RemoteCall<Boolean> isNotarized(String _documentHash)\\\\n\`\`\`\\\\nThis method is quite similar to the \`notarizeDocument(..)\` method, with one major difference;  the returned \`RemoteCall\` is of \`Boolean\` type and not \`TransactionReceipt\`.  This is because a transaction was not sent, and instead the return value of the smart contract function (\`bool\` in this case, converted to \`Boolean\`) is returned synchronously.\\\\n\\\\n### Manual Transaction Sending\\\\nIf for some reason, using the smart contract wrapper is not desirable, Web3j provides a number of helper classes to simplify the process of broadcasting a function invocation transaction, such as encoding the data field of the transaction, and the signing process.\\\\n\\\\n_Manual Transaction Sending Code_\\\\n\`\`\` java\\\\nFunction function = new Function(\\\\\\"notarizeDocument\\\\\\",\\\\n                Arrays.asList(new Utf8String(\\\\\\"QmXoypizjW3WknFiJnKLwHCnL72vedxjQkDDP1mXWo6uco\\\\\\")), Collections.emptyList());\\\\n\\\\n//Encode function values in transaction data format\\\\nString txData = FunctionEncoder.encode(function);\\\\n\\\\nTransactionManager txManager = new FastRawTransactionManager(web3j, creds);\\\\n\\\\nString txHash = txManager.sendTransaction(DefaultGasProvider.GAS_PRICE, DefaultGasProvider.GAS_LIMIT,\\\\n                documentRegistry.getContractAddress(), txData, BigInteger.ZERO).getTransactionHash();\\\\n\`\`\`\\\\n\\\\n- First a \`Function\` object is created.  This defines the \`notarizeDocument\` function call, and contains the function name, a list of input arguments (Web3j provides java equivalents of all solidity smart contract types), and a list of return types (empty in our case).\\\\n\\\\n- Next, the \`FunctionEncoder\` is used to encode the function call definition into the transaction data field format. The actual encoding is out of scope for this article, but details can be found [here](https://solidity.readthedocs.io/en/develop/abi-spec.html) if interested.\\\\n\\\\n- A \`TransactionManager\` is constructed, which which will be used to build and sign the transaction, and broadcast to the Ethereum network. We use a \`FastRawTransactionManager\` in this case, which supports multiple transactions per block, and takes \`Web3j\` and \`Credentials\` objects as arguments. \\\\n\\\\n- Once we have a transaction manager and encoded data, invoking the \`notarizeDocument\` function is simply a matter of calling the \`sendTransaction\` method of the transaction manager.  Behind the scenes this will construct a transaction object, and signing it with the private key defined in the \`Credentials\` and then broadcast the transaction to the Ethereum network via the connected client.  Whereas it was the job of the \`GasProvider\` to set the gas values in the wrapper case, we much specify them manually with this method.  We have used default values in this example but you can change these values as you wish.  As its possible for a smart contract function to receive Ether during the invocation (a \`payable\` function), the last argument can be used to specify the amount of Ether (in the smallest denomination, \`wei\`) that should be sent from the sender account to the smart contract.  No Ether should be transferred in our case, so the value is set to zero.\\\\n\\\\n#### Obtaining the TransactionReceipt\\\\nYou've probably noticed that the \`sendTransaction\` method in the code above, returns a transaction hash, and not a transaction receipt.  This is because of the asynchronous nature of transaction processing that has been mentioned earlier in this guide.  Luckily, web3j also provides a simple way to poll the network and wait until the transaction has been included within a block by a miner, the \`TransactionReceiptProcessor\`:\\\\n\\\\n\`\`\` java\\\\nTransactionReceiptProcessor receiptProcessor =\\\\n                new PollingTransactionReceiptProcessor(web3j, TransactionManager.DEFAULT_POLLING_FREQUENCY,\\\\n                        TransactionManager.DEFAULT_POLLING_ATTEMPTS_PER_TX_HASH);\\\\n\\\\nTransactionReceipt txReceipt = receiptProcessor.waitForTransactionReceipt(txHash);\\\\n\`\`\`\\\\n## Summary\\\\nIn this guide you have learnt how to perform some of the most common interactions with the Ethereum blockchain in java, namely deploying a smart contract and then invoking functions on this contract via both transactions and calls.  Using the generated smart contract java wrappers are by far the easiest way to perform these tasks, but there are other options if you require more granularity.  Congratulations, you're well on your way to becoming a proficient Ethereum java developer!\\\\n\\\\nIn the next article in this series, we will walk you through how to [listen for emitted smart contract events](https://kauri.io/article/760f495423db42f988d17b8c145b0874/listening-for-ethereum-smart-contract-events-in-java).\\\\n\\\\n\\\\n-------------------------------------------\\\\n\\\\n**Next Steps:**\\\\n- [Listening for Ethereum Smart Contract Events in Java](https://kauri.io/article/760f495423db42f988d17b8c145b0874)\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\\\n\\\\n\\\\n\\\\n\\"}",
              "contributors": Array [
                Object {
                  "__typename": "PublicUserDTO",
                  "avatar": "https://api.beta.kauri.io:443/ipfs/QmekAbiDvz3Bc5y4pZB7Gnk5Zgn5iaa5CxQoSmTsDoPkP9",
                  "id": "4d91838268f6d6d4e590e8fd2a001cd91c32e7a4",
                  "name": "Craig Williams",
                  "username": "craig",
                },
                Object {
                  "__typename": "PublicUserDTO",
                  "avatar": "https://api.dev.kauri.io:443/ipfs/QmXa9LzhDV4wiF9YLsv2Z9CBUaSU6ph8QLNRLTDAUBsrA8",
                  "id": "f0f15cedc719b5a55470877b0710d5c7816916b1",
                  "name": "Grégoire Jeanmart",
                  "username": "gregjeanmart",
                },
              ],
              "dateCreated": "2019-07-19T17:17:59.619Z",
              "datePublished": "2019-07-19T17:18:04.060Z",
              "description": "Other articles in this series: - Connecting to an Ethereum client with Java, Eclipse and Web3j - Manage an Ethereum account with Java and Web3j - Generate a Java Wrapper from your Smart Contract - Listening for Ethereum Smart Contract Events in Java - Using Pantheon, the Java Ethereum Client with Linux In this tutorial, you will learn how to deploy a smart contract using the Web3j java library, along with how to interact with the functions of the smart contract. As a prerequisite, you should be",
              "id": "14dc434d11ef4ee18bf7d57f079e246e",
              "owner": Object {
                "__typename": "CommunityDTO",
                "avatar": "https://api.kauri.io:443/ipfs/QmQ9to7bfbR6ADTG2tAKVxWTNw8o3YbwJ1LzdpEJeanLBX",
                "id": "5d2f30daaba2920001c82409",
                "name": "Java Ethereum",
                "resourceIdentifier": Object {
                  "__typename": "ResourceIdentifier",
                  "id": "5d2f30daaba2920001c82409",
                  "type": "COMMUNITY",
                },
              },
              "resourceIdentifier": Object {
                "__typename": "ResourceIdentifier",
                "id": "14dc434d11ef4ee18bf7d57f079e246e",
                "type": "ARTICLE",
              },
              "status": "PUBLISHED",
              "title": "Interacting with an Ethereum Smart Contract in Java",
              "version": 6,
              "voteResult": Object {
                "__typename": "VoteResultDTO",
                "sum": 0,
              },
            },
            Object {
              "__typename": "ArticleDTO",
              "attributes": Object {
                "background": "https://api.kauri.io:443/ipfs/QmeG7oWJ5J8ZHE2p22Ww3buyAxBgWfkNBTx8Xx761n7gsG",
              },
              "author": Object {
                "__typename": "PublicUserDTO",
                "avatar": "https://api.beta.kauri.io:443/ipfs/QmekAbiDvz3Bc5y4pZB7Gnk5Zgn5iaa5CxQoSmTsDoPkP9",
                "id": "4d91838268f6d6d4e590e8fd2a001cd91c32e7a4",
                "name": "Craig Williams",
                "username": "craig",
              },
              "content": "{\\"markdown\\":\\"\\\\n**Other articles in this series:**\\\\n- [Connecting to an Ethereum client with Java, Eclipse and Web3j](https://kauri.io/article/b9eb647c47a546bc95693acc0be72546)\\\\n- [Manage an Ethereum account with Java and Web3j](https://kauri.io/article/925d923e12c543da9a0a3e617be963b4)\\\\n- [Generate a Java Wrapper from your Smart Contract](https://kauri.io/article/84475132317d4d6a84a2c42eb9348e4b)\\\\n- [Interacting with an Ethereum Smart Contract in Java](https://kauri.io/article/14dc434d11ef4ee18bf7d57f079e246e)\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\\\n\\\\n-------------------------------------------\\\\n\\\\n\\\\n## What is a Smart Contract Event\\\\n\\\\nYou can emit an event from any smart contract function triggered by a transaction, and they are an important piece of the Ethereum application architecture puzzle.\\\\n\\\\nThese events consist of a name and up to 17 arguments, with the content of these arguments provided by the emitting function.  Arguments can either be indexed or non-indexed; with indexed arguments allowing for efficient off-chain querying.\\\\n\\\\n> For example, if event X contains an indexed string argument Y, off-chain I can retrieve all events where Y == \\\\\\"foo\\\\\\", using a filter. (More on filters later)\\\\n\\\\nEvents are stored as logs rather than within EVM storage, and because of this, they have properties that you should be aware of:\\\\n\\\\n-   **Not accessible from within a smart contract:** Although smart contract functions emit events, smart contracts cannot access this event information after emission.  This is true for both the emitting contract and any other external contract. Therefore, you cannot use events for cross-contract communication.\\\\n\\\\n-   **Events are cheap!:** As events are stored as logs, they are cheap compared to the traditional approach of updating the EVM storage state.  The exact cost depends on the event specification and the size of the data within the event.\\\\n\\\\n## Common Uses for Events\\\\n\\\\n### Asynchronous Off-chain Triggers\\\\n\\\\nMost enterprise Java developers are familiar with the Event Bus pattern, where events are published to a queue such as RabbitMQ or Amazon SQS.  This pattern allows services that are interested in specific events to consume them off the bus asynchronously, and perform further processing, without any coupling between the publisher and consumer services.\\\\n\\\\n_The Event Bus Pattern_\\\\n![](https://api.dev.kauri.io:443/ipfs/QmUwbWrK2kgPz2RpwghveWcgRQsH1BSiQhHtam6hFpxp1J)\\\\n\\\\nServices can use Ethereum smart contract events in a similar way, with the Ethereum network acting as a kind of messaging queue.  Off-chain services can register an event filter with a node, and will subsequently be notified each time this event is emitted in the Ethereum network.  You can then use these event notifications as a trigger for further off-chain processing, such as updating a NoSQL based cache of the smart contract state.\\\\n\\\\n_Ethereum as an 'Event Bus'_\\\\n![](https://api.dev.kauri.io:443/ipfs/QmaMerpsdaU6xMT7QfJpfCa8ttZa9DuiGDrQaA7GzRiY9d)\\\\n\\\\n### Cheap Data Storage for Off-chain Consumption\\\\n\\\\nAs I mentioned above, storing data within an event rather than in EVM contract storage is significantly cheaper.\\\\n\\\\n> Diving a little bit into the specifics in order to compare, saving 32 bytes of data to contract storage costs 20,000 gas, whereas emitting an event costs 375 plus 375 for each indexed argument, and an additional 8 gas per byte of data.\\\\n\\\\nDue to these cost savings, it's a common pattern to store data never read by an on-chain smart contract function soley in an event, not in contract storage.\\\\n\\\\nAn example of a scenario where this may be the case, is a notary service where an IPFS hash is committed to the Ethereum blockchain in order to prove date of creation.  After an event has been emitted which contains the IPFS hash of the document, you can verify the timestamp of the notarisation off-chain if there is a dispute by querying the contract events, not the contract state.\\\\n\\\\n## Defining and Emitting an Event\\\\n\\\\nBoth defining and emitting and event within your Ethereum smart contracts are one liners:\\\\n\\\\n### Defining\\\\n\\\\n\`\`\`solidity\\\\nevent Notarized(address indexed notary, string documentHash)\\\\n\`\`\`\\\\n\\\\nIn this example we defined an event with the name \`Notarized\`, with an indexed address argument, \`notary\`,  and a single non-indexed string parameter, \`documentHash\`.\\\\n\\\\n### Emitting\\\\n\\\\n\`\`\`solidity\\\\nfunction notarizeDocument(string _documentHash) public {\\\\n        emit Notarized(msg.sender, _documentHash);\\\\n}\\\\n\`\`\`\\\\n\\\\nThe emit keyword fires an event, with arguments passed to the event in a way that is similar to function invocation.  Here, the notary address is set as the transaction sender address via \`msg.sender\`, and the \`documentHash\` is the same as the called function argument.\\\\n\\\\n## Listening for Emitted Events with Web3j\\\\n\\\\nBy far the easiest way to listen for Ethereum smart contract events using web3j is to use the contract wrapper feature of the library.  For a primer on the wrapper feature, see the previous post in this series [http://todo.com](here).\\\\n\\\\nThe below code snippet connects to a local Ethereum node and listens for all Notarized events emitted from a deployed Notary contract:\\\\n\\\\n\`\`\`java\\\\nWeb3j web3j = Web3j.build(new HttpService(\\\\\\"http://localhost:8545\\\\\\"));\\\\n\\\\n//Deploys a notary contract via wrapper\\\\nfinal Notary notaryContract = deployNotaryContract(web3j);\\\\n\\\\nnotaryContract\\\\n        .notarizedEventFlowable(DefaultBlockParameterName.EARLIEST, DefaultBlockParameterName.LATEST)\\\\n        .subscribe(event -> {\\\\n            final String notary = event.notary;\\\\n            final String documentHash = event.documentHash;\\\\n\\\\n            //Perform processing based on event values\\\\n        });\\\\n\`\`\`\\\\n\\\\nThe autogenerated contract wrapper code contains convenience methods for each event defined in your smart contract with the naming pattern \`<event-name>EventFlowable\`.  This method takes start and end block arguments, and as in this example, using the \`DefaultBlockParameterName.LATEST\` value instructs web3j to continue listening for events for new blocks indefinitely.  If you require a specific block range, you can use \`DefaultBlockParameter.valueOf(BigInteger.valueOf(...))\`.  A [Flowable](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html) object is returned which can then be subscribed to, in order to perform processing logic on emitted events.\\\\n\\\\nThis method simplifies the process of event listening, as it automatically converts the raw log messages into an object with fields reflecting the defined event arguments.  Without this, you would have to decode the values yourself, and although web3j provides helper methods for this, things can get complex quickly.\\\\n\\\\n### Filtering by Indexed Argument Value\\\\n\\\\nSetting an argument of an event as \`indexed\` faciliates efficient querying of events by that arguments value.  This querying is supported in Web3j by building an \`EthFilter\` object manually.  Below is the code to listen for events notarized by a specific Ethereum address:\\\\n\\\\n\`\`\`java\\\\nfinal EthFilter ethFilter = new EthFilter(DefaultBlockParameterName.EARLIEST, DefaultBlockParameterName.LATEST,\\\\n                notaryContract.getContractAddress());\\\\n\\\\nethFilter.addSingleTopic(EventEncoder.encode(notaryContract.NOTARIZED_EVENT));\\\\nethFilter.addOptionalTopics(\\\\\\"0x\\\\\\" + TypeEncoder.encode(new Address(\\\\\\"0x00a329c0648769a73afac7f9381e08fb43dbea72\\\\\\")));\\\\n\\\\nnotaryContract\\\\n        .notarizedEventFlowable(ethFilter)\\\\n        .subscribe(event -> {\\\\n            final String notary = event.notary;\\\\n            final String documentHash = event.documentHash;\\\\n\\\\n            //Perform processing based on event values\\\\n        });\\\\n\`\`\`\\\\n\\\\nThe \`notarizedEventFlowable\` is overloaded, and can accept an \`EthFilter\` as an argument, rather than a block range.  This filter is used to define which events to listen for in a more finely grained way, and is built up with the same block range as was previously passed to the method.\\\\n\\\\nThere are also some topics that are set on the filter.  In an Ethereum filter, the first topic is always defined as the keccak hash of the event signature, with the event signature in our case being \`'Notarised(address,string)''\`.  This is calculated with the help of the \`EventEncoder.encode(..)\` method provided by Web3j, along with the event specification, \`NOTARIZED_EVENT\` that has been auto-generated in the wrapper class.\\\\n\\\\nAdditional topics can be added using the \`addOptionalTopics(..)\` method, and these specify the values of indexed arguments to match against, in the same order as they are defined in the event specification.  Encoding varies slightly based on the type of the argument, but luckily, Web3j provides the \`TypeEncoder\` class which handles this for us.  In the example provided, we are only listening for events where the \`notary\` value is the address 0x00a329c0648769a73afac7f9381e08fb43dbea72.\\\\n\\\\n## Summary\\\\nEvents are a great way for backend (and frontend) services to be notified of smart contract changes and interactions in an asynchronous manner, as well a providing a cost effective way of storing data on the Ethereum blockchain that does not need to be consumed by a smart contract.\\\\n\\\\nAs with many Ethereum interactions, the smart contract wrappers generated by Web3j are by far the simplest way to subscribe to, and process emitted events in your java backend.\\\\n\\\\n\\\\n-------------------------------------------\\\\n\\\\n**Next Steps:**\\\\n- [Using Pantheon, the Java Ethereum Client with Linux](https://kauri.io/article/276dd27f1458443295eea58403fd6965)\\\\n\\"}",
              "contributors": Array [
                Object {
                  "__typename": "PublicUserDTO",
                  "avatar": "https://api.beta.kauri.io:443/ipfs/QmekAbiDvz3Bc5y4pZB7Gnk5Zgn5iaa5CxQoSmTsDoPkP9",
                  "id": "4d91838268f6d6d4e590e8fd2a001cd91c32e7a4",
                  "name": "Craig Williams",
                  "username": "craig",
                },
                Object {
                  "__typename": "PublicUserDTO",
                  "avatar": "https://api.dev.kauri.io:443/ipfs/QmXa9LzhDV4wiF9YLsv2Z9CBUaSU6ph8QLNRLTDAUBsrA8",
                  "id": "f0f15cedc719b5a55470877b0710d5c7816916b1",
                  "name": "Grégoire Jeanmart",
                  "username": "gregjeanmart",
                },
              ],
              "dateCreated": "2019-07-22T09:10:19.848Z",
              "datePublished": "2019-07-22T09:10:23.268Z",
              "description": "Other articles in this series: - Connecting to an Ethereum client with Java, Eclipse and Web3j - Manage an Ethereum account with Java and Web3j - Generate a Java Wrapper from your Smart Contract - Interacting with an Ethereum Smart Contract in Java - Using Pantheon, the Java Ethereum Client with Linux What is a Smart Contract Event You can emit an event from any smart contract function triggered by a transaction, and they are an important piece of the Ethereum application architecture puzzle. Th",
              "id": "760f495423db42f988d17b8c145b0874",
              "owner": Object {
                "__typename": "CommunityDTO",
                "avatar": "https://api.kauri.io:443/ipfs/QmQ9to7bfbR6ADTG2tAKVxWTNw8o3YbwJ1LzdpEJeanLBX",
                "id": "5d2f30daaba2920001c82409",
                "name": "Java Ethereum",
                "resourceIdentifier": Object {
                  "__typename": "ResourceIdentifier",
                  "id": "5d2f30daaba2920001c82409",
                  "type": "COMMUNITY",
                },
              },
              "resourceIdentifier": Object {
                "__typename": "ResourceIdentifier",
                "id": "760f495423db42f988d17b8c145b0874",
                "type": "ARTICLE",
              },
              "status": "PUBLISHED",
              "title": "Listening for Ethereum Smart Contract Events in Java",
              "version": 4,
              "voteResult": Object {
                "__typename": "VoteResultDTO",
                "sum": 0,
              },
            },
            Object {
              "__typename": "ArticleDTO",
              "attributes": Object {
                "background": "https://api.kauri.io:443/ipfs/QmUzvLvjLLisUjUunfW81gqCuZ32Uhn5mdiidJ7ArKkkb4",
              },
              "author": Object {
                "__typename": "PublicUserDTO",
                "avatar": "https://api.kauri.io:443/ipfs/QmUR61QiSMk1XqBaAyvA7WmgVBP44x7RQMBa8RU3DCMp6f",
                "id": "824e8fa64ff92b859cc9991ac044e00b665b9b04",
                "name": "Felipe Faraggi",
                "username": "felipefaraggi",
              },
              "content": "{\\"markdown\\":\\"![Toolbelt: Pantheon included!](https://i.imgur.com/LhdU0DH.jpg)\\\\nOriginal photo by [Jesse Orrico](https://unsplash.com/@jessedo81?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)\\\\n\\\\nThis is the first article of a 3-part series on installing Pantheon, the Java client for Ethereum:\\\\n\\\\n1.  [Linux](#)\\\\n2.  macOS\\\\n3.  Windows\\\\n\\\\nHaving some powerful tools in your toolbelt is essential for a Java developer, and one of the crucial tools for an Ethereum blockchain developer is the network client. This is the piece of software that communicates data to and from the blockchain. Among other things, the client: spins up nodes, acts as a peer discovery agent to see who else is participating in the network and validates and sends transactions.\\\\n\\\\nThis guide helps you install and setup this core part you need for programming on Ethereum with Java. Although there are some great networking clients out there, Pantheon is the only one written in Java.\\\\n\\\\nPantheon is an open-source, Apache 2.0 licensed Ethereum client written in Java. It is mainnet compatible, has a modular architecture, and has privacy and permissioning features as well as new consensus algorithms.\\\\n\\\\nThis is the first of a series of step-by-step guides to install and configure the Pantheon client on Linux/macOS/Windows. This guide focuses on Linux operating system, but you can use many of the commands and steps on macOS with some basic modifications.\\\\n\\\\n## Try Pantheon with Docker\\\\n\\\\nBefore installing, I would suggest anyone wanting to setup and install Pantheon for the first time to try it out using our [Docker images](http://docs.pantheon.pegasys.tech/en/stable/Getting-Started/Run-Docker-Image/). The requirements to do so are having [Docker installed](https://docs.docker.com/v17.12/install/linux/docker-ce/ubuntu/) and using Linux or macOS.\\\\nYou can use a single docker command to run a mainnet, local or rinkeby version of Pantheon, and then use [\`curl\`](https://curl.haxx.se/) or similar tools to get or post data to the running node.\\\\n\\\\n> For quick, temporary tests this guide uses \`/tmp/pantheon/dev/\`, \`/tmp/pantheon/mainnet/\`, \`/tmp/pantheon/rinkeby/\` as mount volumes, which are automatically cleaned at every boot. You can create other folders instead, but whichever option you choose, make sure you create the folders first.\\\\n\\\\n\`\`\`shell\\\\n$ mkdir -p /tmp/pantheon/dev/\\\\n$ mkdir -p /tmp/pantheon/mainnet/\\\\n$ mkdir -p /tmp/pantheon/rinkeby/\\\\n\`\`\`\\\\n\\\\nHere are some examples:\\\\n\\\\nMainnet Node:\\\\n\\\\n\`\`\`shell\\\\ndocker run pegasyseng/pantheon:latest\\\\n\`\`\`\\\\n\\\\nLocal test Node with Websockets and HTTP RPC services enabled:\\\\n\\\\n\`\`\`shell\\\\ndocker run -p 8545:8545 -p 8546:8546 --mount type=bind,source=/tmp/pantheon/dev,target=/var/lib/pantheon pegasyseng/pantheon:latest --miner-enabled --miner-coinbase fe3b557e8fb62b89f4916b721be55ceb828dbd73 --rpc-http-cors-origins=\\\\\\"all\\\\\\" --rpc-ws-enabled --network=dev\\\\n\`\`\`\\\\n\\\\nRinkeby Node:\\\\n\\\\n\`\`\`shell\\\\ndocker run -p 30303:30303 --mount type=bind,source=/tmp/pantheon/rinkeby,target=/var/lib/pantheon pegasyseng/pantheon:latest --network=rinkeby\\\\n\`\`\`\\\\n\\\\nWhile the node is running, you can use another terminal window to interact with the node.\\\\n\\\\n![](https://i.imgur.com/kw1VHDs.png)\\\\n\\\\nFor example, using \`curl\` to call the \`eth_chainId\` RPC method:\\\\n\\\\n\`\`\`shell\\\\ncurl -X POST --data '{\\\\\\"jsonrpc\\\\\\":\\\\\\"2.0\\\\\\",\\\\\\"method\\\\\\":\\\\\\"eth_chainId\\\\\\",\\\\\\"params\\\\\\":[],\\\\\\"id\\\\\\":1}' localhost:8545\\\\n\`\`\`\\\\n\\\\n* * *\\\\n\\\\n## Getting started with Linux\\\\n\\\\nTwo installation methods are available:\\\\n\\\\n-   [Installing the binary distribution](http://docs.pantheon.pegasys.tech/en/stable/Installation/Install-Binaries/)\\\\n    For binary installation, [follow along to this section](#binary-install) and skip the next.\\\\n-   [Building from source](http://docs.pantheon.pegasys.tech/en/stable/Installation/Build-From-Source/)\\\\n    For building from source, [skip to this section](#build-from-source).\\\\n\\\\n> **Requirements**: For both of these methods, Pantheon needs the Java JDK installed on your machine. Current versions of Pantheon require Java JDK 11+ installed.\\\\n\\\\n### Binary install\\\\n\\\\nRemember to have at least 4GB of RAM if running a private network, and [review  the further requirements](http://docs.pantheon.pegasys.tech/en/stable/Installation/Overview/#disk-space-and-ram-requirements) for other installation types.\\\\n\\\\n1.  [Download the Pantheon binaries](https://bintray.com/consensys/pegasys-repo/pantheon/_latestVersion#files).\\\\n\\\\nYou can use \`wget\` to do this.\\\\n\\\\n\`\`\`shell\\\\n$ sudo apt install wget\\\\n$ cd ~/bin/\\\\n$ wget   https://bintray.com/consensys/pegasys-repo/download_file?file_path=pantheon-1.1.4.tar.gz -O pantheon-1.1.4.tar.gz\\\\n$ wget https://bintray.com/consensys/pegasys-repo/download_file\\\\\\\\?file_path\\\\\\\\=pantheon-1.1.4.tar.gz -O pantheon-1.1.4.tar.gz\\\\n\`\`\`\\\\n\\\\n> \`$HOME/bin/\` and \`$HOME/.local/{bin,opt,usr}\` are the recommended install folders for local user binaries on machines used by a single user. Other options are available such as \`/opt/local/\` or \`/usr/local/bin/\` depending on your local setup and preference. [Read this Stack Exchange thread for more details](https://unix.stackexchange.com/questions/36871/where-should-a-local-executable-be-placed).\\\\n\\\\n2.  Unpack the compressed file:\\\\n\\\\n\`\`\`shell\\\\n$ tar -xzf pantheon-1.1.4.tar.gz\\\\n$ cd pantheon-1.1.4\\\\n\`\`\`\\\\n\\\\n> Replace 1.1.4 with whichever release you downloaded.\\\\n\\\\n3.  Confirm the download isn't corrupted and check the version .The output should return the Pantheon and JDK version.\\\\n\\\\n\`\`\`shell\\\\n$ bin/pantheon --version\\\\npantheon/v1.1.4/linux-x86_64/oracle_openjdk-java-11\\\\n\`\`\`\\\\n\\\\n### Build from Source\\\\n\\\\nTwo options are available: [installing and running locally](http://docs.pantheon.pegasys.tech/en/stable/Installation/Build-From-Source/#installation-on-linux-unix-mac-os-x) or [on a VM](http://docs.pantheon.pegasys.tech/en/stable/Installation/Build-From-Source/#installation-on-vm).\\\\n\\\\nThis guide focuses on the local solution.\\\\n\\\\n1.  Clone the Pantheon codebase\\\\n\\\\n\`\`\`shell\\\\n$ cd ~/bin/\\\\n$ git clone --recursive https://github.com/PegaSysEng/pantheon.git\\\\n\`\`\`\\\\n\\\\n2.  Build Pantheon\\\\n\\\\n\`\`\`shell\\\\n$ cd pantheon/\\\\n$ ./gradlew build -x test\\\\n\`\`\`\\\\n\\\\n3.  Choose distribution version and check version.\\\\n\\\\n\`\`\`shell\\\\n$ cd build/distributions/\\\\n$ tar -xzf pantheon-1.1.4.tar.gz\\\\n$ cd pantheon-1.1.4/\\\\n$ bin/pantheon --version\\\\n$ bin/pantheon --help\\\\n\`\`\`\\\\n\\\\n## Config\\\\n\\\\nNo additional configuration is necessary for Pantheon to run correctly.\\\\nEach different network type (including mainnet) set by the \`--network\` command line flags automatically loads the appropriate default configuration.\\\\n\\\\nIf you need to change the settings, these options are either configured at Node or Network-level.\\\\nNetwork-level settings are defined in the genesis file and are loaded by every Node connected to that specific network. Whereas Node-level settings are modified either in the node configuration file, or through command line flags.\\\\n\\\\nFor more information on configuration, [read the corresponding documentation](http://docs.pantheon.pegasys.tech/en/stable/Configuring-Pantheon/Network-vs-Node/).\\\\n\\\\n## Starting Pantheon\\\\n\\\\nAfter you have completed the above steps, you can continue using this distribution with the [regular Starting Pantheon guide](http://docs.pantheon.pegasys.tech/en/stable/Getting-Started/Starting-Pantheon/).\\\\n\\\\nFor a quick preview, this could be an HTTP request on a \`dev\` network Node running with docker.\\\\n\\\\n\`\`\`shell\\\\n$ docker run -p 8545:8545 --mount type=bind,source=/tmp/pantheon/dev,target=/var/lib/pantheon pegasyseng/pantheon:latest --miner-enabled --miner-coinbase fe3b557e8fb62b89f4916b721be55ceb828dbd73 --rpc-http-cors-origins=\\\\\\"all\\\\\\" --rpc-http-enabled --network=dev\\\\n\`\`\`\\\\n\\\\nThis is how you build a request calling the \`eth_chainId\` method.\\\\n\\\\n\`\`\`java\\\\nString payload='{\\\\\\"jsonrpc\\\\\\":\\\\\\"2.0\\\\\\",\\\\\\"method\\\\\\":\\\\\\"eth_chainId\\\\\\",\\\\\\"params\\\\\\":[],\\\\\\"id\\\\\\":1}';\\\\nString requestUrl=\\\\\\"http://localhost:8545\\\\\\";\\\\nsendRequest(requestUrl, payload);\\\\n\`\`\`\\\\n\\\\nAnd the method implementation:\\\\n\\\\n\`\`\`java\\\\npublic static String sendRequest(String requestUrl, String payload) {\\\\n    try {\\\\n        URL url = new URL(requestUrl);\\\\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\\\\n\\\\n        connection.setDoInput(true);\\\\n        connection.setDoOutput(true);\\\\n        connection.setRequestMethod(\\\\\\"GET\\\\\\");\\\\n        connection.setRequestProperty(\\\\\\"Accept\\\\\\", \\\\\\"application/json\\\\\\");\\\\n        connection.setRequestProperty(\\\\\\"Content-Type\\\\\\", \\\\\\"application/json; charset=UTF-8\\\\\\");\\\\n        OutputStreamWriter outputWriter = new OutputStreamWriter(connection.getOutputStream(), \\\\\\"UTF-8\\\\\\");\\\\n\\\\n        outputWriter.write(payload);\\\\n        outputWriter.close();\\\\n\\\\n        BufferedReader buffer = new BufferedReader(new InputStreamReader(connection.getInputStream()));\\\\n        StringBuffer jsonString = new StringBuffer();\\\\n        String line;\\\\n        while ((line = buffer.readLine()) != null) {\\\\n                jsonString.append(line);\\\\n        }\\\\n        buffer.close();\\\\n\\\\n        connection.disconnect();\\\\n        return jsonString.toString();\\\\n    } catch (Exception e) {\\\\n            throw new RuntimeException(e.getMessage());\\\\n    }\\\\n}\\\\n\`\`\`\\\\n\\\\nThat request should return the following result:\\\\n\\\\n\`\`\`json\\\\n{\\\\n  \\\\\\"jsonrpc\\\\\\" : \\\\\\"2.0\\\\\\",\\\\n  \\\\\\"id\\\\\\" : 1,\\\\n  \\\\\\"result\\\\\\" : {\\\\n    \\\\\\"startingBlock\\\\\\" : \\\\\\"0x0\\\\\\",\\\\n    \\\\\\"currentBlock\\\\\\" : \\\\\\"0x2d0\\\\\\",\\\\n    \\\\\\"highestBlock\\\\\\" : \\\\\\"0x66c0\\\\\\"\\\\n  }\\\\n}\\\\n\`\`\`\\\\n\\\\nFine more information in the [Pantheon documentation](http://docs.pantheon.pegasys.tech/en/stable/).\\"}",
              "contributors": Array [
                Object {
                  "__typename": "PublicUserDTO",
                  "avatar": "https://api.kauri.io:443/ipfs/QmUR61QiSMk1XqBaAyvA7WmgVBP44x7RQMBa8RU3DCMp6f",
                  "id": "824e8fa64ff92b859cc9991ac044e00b665b9b04",
                  "name": "Felipe Faraggi",
                  "username": "felipefaraggi",
                },
              ],
              "dateCreated": "2019-07-19T12:57:15.901Z",
              "datePublished": "2019-07-19T12:57:18.891Z",
              "description": "Toolbelt: Pantheon included! Original photo by Jesse Orrico This is the first article of a 3-part series on installing Pantheon, the Java client for Ethereum: Linux macOS Windows Having some powerful tools in your toolbelt is essential for a Java developer, and one of the crucial tools for an Ethereum blockchain developer is the network client. This is the piece of software that communicates data to and from the blockchain. Among other things, the client: spins up nodes, acts as a peer discovery",
              "id": "276dd27f1458443295eea58403fd6965",
              "owner": Object {
                "__typename": "CommunityDTO",
                "avatar": "https://api.kauri.io:443/ipfs/QmQ9to7bfbR6ADTG2tAKVxWTNw8o3YbwJ1LzdpEJeanLBX",
                "id": "5d2f30daaba2920001c82409",
                "name": "Java Ethereum",
                "resourceIdentifier": Object {
                  "__typename": "ResourceIdentifier",
                  "id": "5d2f30daaba2920001c82409",
                  "type": "COMMUNITY",
                },
              },
              "resourceIdentifier": Object {
                "__typename": "ResourceIdentifier",
                "id": "276dd27f1458443295eea58403fd6965",
                "type": "ARTICLE",
              },
              "status": "PUBLISHED",
              "title": "Using Pantheon, the Java Ethereum Client with Linux",
              "version": 2,
              "voteResult": Object {
                "__typename": "VoteResultDTO",
                "sum": 0,
              },
            },
          ],
          "resourcesId": Array [
            Object {
              "__typename": "ResourceIdentifier",
              "id": "b9eb647c47a546bc95693acc0be72546",
              "type": "ARTICLE",
            },
            Object {
              "__typename": "ResourceIdentifier",
              "id": "925d923e12c543da9a0a3e617be963b4",
              "type": "ARTICLE",
            },
            Object {
              "__typename": "ResourceIdentifier",
              "id": "84475132317d4d6a84a2c42eb9348e4b",
              "type": "ARTICLE",
            },
            Object {
              "__typename": "ResourceIdentifier",
              "id": "14dc434d11ef4ee18bf7d57f079e246e",
              "type": "ARTICLE",
            },
            Object {
              "__typename": "ResourceIdentifier",
              "id": "760f495423db42f988d17b8c145b0874",
              "type": "ARTICLE",
            },
            Object {
              "__typename": "ResourceIdentifier",
              "id": "276dd27f1458443295eea58403fd6965",
              "type": "ARTICLE",
            },
          ],
        },
        Object {
          "__typename": "SectionDTO",
          "description": "Section coming soon...",
          "name": "Intermediate",
          "resources": Array [],
          "resourcesId": Array [],
        },
        Object {
          "__typename": "SectionDTO",
          "description": "Section coming soon...",
          "name": "Advanced",
          "resources": Array [],
          "resourcesId": Array [],
        },
      ]
    }
    href={
      Object {
        "as": "/java-ethereum/5d2f30daaba2920001c82409/cm",
        "href": "/community_id=5d2f30daaba2920001c82409",
      }
    }
    id="5d2f30daaba2920001c82409"
    key="5d2f30daaba2920001c82409"
    members={
      Array [
        Object {
          "__typename": "CommunityMemberDTO",
          "avatar": "https://api.dev.kauri.io:443/ipfs/QmXa9LzhDV4wiF9YLsv2Z9CBUaSU6ph8QLNRLTDAUBsrA8",
          "id": "f0f15cedc719b5a55470877b0710d5c7816916b1",
          "name": "Grégoire Jeanmart",
          "role": "ADMIN",
          "status": "EMAIL_VERIFIED",
          "username": "gregjeanmart",
        },
        Object {
          "__typename": "CommunityMemberDTO",
          "avatar": "https://api.beta.kauri.io:443/ipfs/QmekAbiDvz3Bc5y4pZB7Gnk5Zgn5iaa5CxQoSmTsDoPkP9",
          "id": "4d91838268f6d6d4e590e8fd2a001cd91c32e7a4",
          "name": "Craig Williams",
          "role": "ADMIN",
          "status": "EMAIL_VERIFIED",
          "username": "craig",
        },
        Object {
          "__typename": "CommunityMemberDTO",
          "avatar": "https://api.kauri.io:443/ipfs/QmUR61QiSMk1XqBaAyvA7WmgVBP44x7RQMBa8RU3DCMp6f",
          "id": "824e8fa64ff92b859cc9991ac044e00b665b9b04",
          "name": "Felipe Faraggi",
          "role": "ADMIN",
          "status": "EMAIL_VERIFIED",
          "username": "felipefaraggi",
        },
        Object {
          "__typename": "CommunityMemberDTO",
          "avatar": "https://api.kauri.io:443/ipfs/QmTgYVnxH9Ggj48erSjpuJkmPSncE4W3GND5LBt3twhXzA",
          "id": "3638ed27d6e2f9e3494ff3d78f309cea7d898ebc",
          "name": "FerParis",
          "role": "CURATOR",
          "status": "EMAIL_VERIFIED",
          "username": "Paris",
        },
        Object {
          "__typename": "CommunityMemberDTO",
          "avatar": "https://api.beta.kauri.io:443/ipfs/Qmf3VwAmcivMAFzRoDJgzJ3hgrjAEKvDh3i7Lm8zAoQnw3",
          "id": "9b66e2c73ee59c11ac25ef2730ab589c5416e81a",
          "name": "Chris Ward",
          "role": "ADMIN",
          "status": "EMAIL_VERIFIED",
          "username": "ChrisChinchilla",
        },
        Object {
          "__typename": "CommunityMemberDTO",
          "avatar": "https://api.kauri.io:443/ipfs/QmdEzWvkc3NkUbJrZjXPRc2ayrffRq7JM9EyYvsmoHz7NA",
          "id": "e690a3445bf1f5138eb3b3c15d6fd524d0307e05",
          "name": "Ivaylo Kirilov",
          "role": "CURATOR",
          "status": "EMAIL_VERIFIED",
          "username": "iikirilov",
        },
        Object {
          "__typename": "CommunityMemberDTO",
          "avatar": "https://api.kauri.io:443/ipfs/QmYS41Ey2Ri8rinvvcLB4xvZffwVXqJYpwrsFphAGiVwR1",
          "id": "1ac7bb851ac961b74b35f5e9f0319a23cdcb20f9",
          "name": "Javier",
          "role": "CURATOR",
          "status": "EMAIL_VERIFIED",
          "username": "janayama",
        },
      ]
    }
    name="Java Ethereum"
    pending={Array []}
    pendingId={Array []}
    resourceIdentifier={
      Object {
        "__typename": "ResourceIdentifier",
        "id": "b9eb647c47a546bc95693acc0be72546",
        "type": "COMMMUNITY",
      }
    }
    social={Object {}}
    status="OPENED"
    tags={
      Array [
        "ethereum",
        "java",
        "web3j",
        "pantheon",
      ]
    }
    website=""
  />
  <PrimaryButtonComponent
    onClick={[Function]}
  >
    View Community
  </PrimaryButtonComponent>
</View__Container>
`;
